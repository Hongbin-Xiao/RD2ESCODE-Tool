[
  {
    "role": "system",
    "content": "You will play the role of an experienced embedded system design engineer guiding the modification of erroneous code and completion of requirements.\nI will provide you with the project's requirements document and three correct code references. After that, I will provide you with the erroneous code:\nIf the code provided to you is erroneous, please provide modification ideas for the erroneous code based on the correct code to make it align with the correct code.\nOutput requirements: (... represents the content you need to fill in)\nCode modification approach:'''...'''\nSolution:'''...'''"
  },
  {
    "role": "user",
    "content": "参考代码1：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X = 0, DIR_Y = 0;\nuchar loop = 0, AD_Up = 0, AD_Down = 0, AD_Left = 0, AD_Right = 0, ms = 0, blink_ms = 0;\nbit Up_CB = 0, Down_CB = 0, Left_CB = 0, Right_CB = 0, SYS_mode = 0, SYS_ERROR = 0;\n\n// --- I2C Module ---\nvoid I2C_Delay() {;}\nvoid I2C_Start()  { SDA = 1; I2C_Delay(); SCL = 1; I2C_Delay(); SDA = 0; I2C_Delay(); }\nvoid I2C_Stop()   { SDA = 0; I2C_Delay(); SCL = 1; I2C_Delay(); SDA = 1; I2C_Delay(); }\nvoid I2C_Respons() { uchar i = 0; SCL = 1; I2C_Delay(); while((SDA==1)&&(i<250)) i++; SCL = 0; I2C_Delay(); }\nvoid I2C_Init()   { SDA = 1; I2C_Delay(); SCL = 1; I2C_Delay(); }\nuchar I2C_ReadByte() {\n    uchar i, k = 0;\n    SCL = 0; I2C_Delay(); SDA = 1; I2C_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; I2C_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; I2C_Delay();\n    }\n    return k;\n}\nvoid I2C_WriteByte(uchar date) {\n    uchar i, temp = date;\n    for (i = 0; i < 8; i++) {\n        temp <<= 1;\n        SCL = 0; I2C_Delay();\n        SDA = CY;\n        I2C_Delay();\n        SCL = 1; I2C_Delay();\n    }\n    SCL = 0; I2C_Delay(); SDA = 1; I2C_Delay();\n}\n// --- PCF8591 Module ---\nvoid PCF8591_Write(uchar control, uchar date) {\n    I2C_Start();\n    I2C_WriteByte(PCF8591); I2C_Respons();\n    I2C_WriteByte(control); I2C_Respons();\n    I2C_WriteByte(date); I2C_Respons();\n    I2C_Stop();\n}\nuchar PCF8591_Read(uchar control) {\n    uchar date;\n    I2C_Start();              I2C_WriteByte(PCF8591); I2C_Respons();\n    I2C_WriteByte(control);   I2C_Respons();\n    I2C_Start();\n    I2C_WriteByte(PCF8591+1); I2C_Respons();\n    date = I2C_ReadByte();\n    I2C_Stop();\n    return date;\n}\nuchar PCF8591_DAC(uchar light) {\n    I2C_Start(); I2C_WriteByte(PCF8591); I2C_Respons();\n    I2C_WriteByte(0x40); I2C_Respons();\n    I2C_WriteByte(light); I2C_Respons();\n    I2C_Stop();\n    return 1;\n}\n// --- UTIL Module ---\nvoid UTIL_Delay(uint T) { while(T--); }\n// --- Key Module ---\nvoid KEY_Scan() {\n    if (!key_state) {\n        UTIL_Delay(1000);\n        if (!key_state) {\n            while(!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n    if (!SYS_mode) {\n        if (!key_Up)      { Up_CB = 1; Down_CB = 0; }\n        else if (!key_Down) { Up_CB = 0; Down_CB = 1; }\n        else { Down_CB = 0; Up_CB = 0; }\n        if (!key_Left)      { Left_CB = 1; Right_CB = 0; }\n        else if (!key_Right) { Left_CB = 0; Right_CB = 1; }\n        else { Right_CB = 0; Left_CB = 0; }\n    }\n}\n// --- PROC Module ---\nvoid PROC_Run() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up-AD_Down>=Tol) Down_CB = 1;\n            else if (AD_Up-AD_Down<=4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down-AD_Up>=Tol) Up_CB = 1;\n            else if (AD_Down-AD_Up<=4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left-AD_Right>=Tol) Left_CB = 1;\n            else if (AD_Left-AD_Right<=7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right-AD_Left>=Tol) Right_CB = 1;\n            else if (AD_Right-AD_Left<=7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n// --- LED Module ---\nvoid LED_Update() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) { led_1 = 0; led_2 = 1; }\n        else           { led_1 = 1; led_2 = 0; }\n    }\n}\n// --- Main Application Logic ---\nvoid main(void) {\n    TMOD = 0x01; TH0 = 0xf6; TL0 = 0x3b;\n    EA = 1; ET0 = 1; TR0 = 1;\n    I2C_Init();\n    while (1) {\n        KEY_Scan();\n        AD_Down = PCF8591_Read(0x00);\n        AD_Up   = PCF8591_Read(0x01);\n        AD_Right= PCF8591_Read(0x02);\n        AD_Left = PCF8591_Read(0x03);\n        if (AD_Down==255 || AD_Down==0 || AD_Up==255 || AD_Up==0 ||\n            AD_Right==255 || AD_Right==0 || AD_Left==255 || AD_Left==0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n        PROC_Run();\n        LED_Update();\n    }\n}\n\nvoid TIMER0_ISR() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n\n    if (Up_CB)\n        P2 = P2&0xf0 | FirstSet_FWD[loop];\n    else if (Down_CB)\n        P2 = P2&0xf0 | FirstSet_REV[loop];\n    else\n        P2 = P2&0xf0;\n\n    if (Left_CB)\n        P2 = P2&0x0f | Secondset_FWD[loop];\n    else if (Right_CB)\n        P2 = P2&0x0f | Secondset_REV[loop];\n    else\n        P2 = P2&0x0f;\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n---\n参考代码2：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X = 0, DIR_Y = 0;\nuchar loop = 0, AD_Up = 0, AD_Down = 0, AD_Left = 0, AD_Right = 0, ms = 0, blink_ms = 0;\nbit Up_CB = 0, Down_CB = 0, Left_CB = 0, Right_CB = 0, SYS_mode = 0, SYS_ERROR = 0;\n\nvoid PCF8591_Delay() {;}\n\nvoid start() {\n    SDA = 1; PCF8591_Delay(); SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid stop() {\n    SDA = 0; PCF8591_Delay(); SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid respons() {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid init() {\n    SDA = 1; PCF8591_Delay(); SCL = 1; PCF8591_Delay();\n}\n\nuchar read_byte() {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay(); SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid write_byte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay(); SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid write_add(uchar control, uchar date) {\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    write_byte(date);\n    respons();\n    stop();\n}\n\nuchar read_add(uchar control) {\n    uchar date;\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    start();\n    write_byte(PCF8591 + 1);\n    respons();\n    date = read_byte();\n    stop();\n    return date;\n}\n\nuchar DAC(uchar light) {\n    start();\n    write_byte(PCF8591); respons();\n    write_byte(0x40); respons();\n    write_byte(light); respons();\n    stop();\n    return (1);\n}\n\nvoid delay(uint T) {\n    while (T--);\n}\n\nvoid key() {\n    if (!key_state) {\n        delay(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n    if (!SYS_mode) {\n        if (!key_Up) { Up_CB = 1; Down_CB = 0; }\n        else if (!key_Down) { Up_CB = 0; Down_CB = 1; }\n        else { Down_CB = 0; Up_CB = 0; }\n        if (!key_Left) { Left_CB = 1; Right_CB = 0; }\n        else if (!key_Right) { Left_CB = 0; Right_CB = 1; }\n        else { Right_CB = 0; Left_CB = 0; }\n    }\n}\n\nvoid proc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01; TH0 = 0xf6; TL0 = 0x3b;\n    EA = 1; ET0 = 1; TR0 = 1;\n    init();\n    while (1) {\n        key();\n        AD_Down = read_add(0x00);\n        AD_Up = read_add(0x01);\n        AD_Right = read_add(0x02);\n        AD_Left = read_add(0x03);\n        if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n            AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n        proc();\n        if (SYS_ERROR == 0) {\n            if (!SYS_mode) { led_1 = 0; led_2 = 1; }\n            else { led_1 = 1; led_2 = 0; }\n        }\n    }\n}\n\nvoid init_1() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n    loop = (loop + 1) % 8;\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n---\n参考代码3：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X = 0, DIR_Y = 0;\nuchar loop = 0, AD_Up = 0, AD_Down = 0, AD_Left = 0, AD_Right = 0, ms = 0, blink_ms = 0;\nbit Up_CB = 0, Down_CB = 0, Left_CB = 0, Right_CB = 0, SYS_mode = 0, SYS_ERROR = 0;\n\nvoid delay(uint T) { while(T--); }\nvoid PCF8591_Delay() { ; }\n\nvoid I2C_start()  { SDA=1; PCF8591_Delay(); SCL=1; PCF8591_Delay(); SDA=0; PCF8591_Delay(); }\nvoid I2C_stop()   { SDA=0; PCF8591_Delay(); SCL=1; PCF8591_Delay(); SDA=1; PCF8591_Delay(); }\nvoid I2C_respons(){ uchar i=0; SCL=1; PCF8591_Delay(); while((SDA==1)&&(i<250)) i++; SCL=0; PCF8591_Delay(); }\nvoid I2C_init()   { SDA=1; PCF8591_Delay(); SCL=1; PCF8591_Delay(); }\nuchar I2C_read_byte() {\n    uchar i, k=0;\n    SCL=0; PCF8591_Delay(); SDA=1; PCF8591_Delay();\n    for(i=0; i<8; i++) { SCL=1; PCF8591_Delay(); k=(k<<1)|SDA; SCL=0; PCF8591_Delay(); }\n    return k;\n}\nvoid I2C_write_byte(uchar date) {\n    uchar i, temp;\n    temp=date;\n    for(i=0; i<8; i++) {\n        temp=temp<<1;\n        SCL=0; PCF8591_Delay();\n        SDA=CY;\n        PCF8591_Delay();\n        SCL=1; PCF8591_Delay();\n    }\n    SCL=0; PCF8591_Delay();\n    SDA=1; PCF8591_Delay();\n}\n\nvoid stepper_ctrl() {\n    if(Up_CB)\n        P2 = P2&0xf0 | FirstSet_FWD[loop];\n    else if(Down_CB)\n        P2 = P2&0xf0 | FirstSet_REV[loop];\n    else\n        P2 = P2&0xf0;\n\n    if(Left_CB)\n        P2 = P2&0x0f | Secondset_FWD[loop];\n    else if(Right_CB)\n        P2 = P2&0x0f | Secondset_REV[loop];\n    else\n        P2 = P2&0x0f;\n\n    loop=(loop+1)%8;\n}\n\nvoid system_error_blink() {\n    if(SYS_ERROR == 1) {\n        blink_ms++;\n        if(blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n\nvoid read_keys() {\n    if (!key_state) {\n        delay(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB=Up_CB=Right_CB=Left_CB=0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n    if (!SYS_mode) {\n        if (!key_Up)      { Up_CB = 1; Down_CB = 0; }\n        else if (!key_Down) { Up_CB = 0; Down_CB = 1; }\n        else { Down_CB = 0; Up_CB = 0; }\n\n        if (!key_Left)    { Left_CB = 1; Right_CB = 0; }\n        else if (!key_Right) { Left_CB = 0; Right_CB = 1; }\n        else { Right_CB = 0; Left_CB = 0; }\n    }\n}\n\nvoid system_proc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nuchar PCF_read(uchar control) {\n    uchar date;\n    I2C_start();              I2C_write_byte(PCF8591); I2C_respons();\n    I2C_write_byte(control);  I2C_respons();\n    I2C_start();\n    I2C_write_byte(PCF8591+1);I2C_respons();\n    date=I2C_read_byte();\n    I2C_stop();\n    return date;\n}\n\nvoid update_leds() {\n    if(SYS_ERROR == 0) {\n        if(!SYS_mode) {led_1 = 0; led_2 = 1;}\n        else {led_1 = 1; led_2 = 0;}\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01; TH0 = 0xf6; TL0 = 0x3b; EA = 1; ET0 = 1; TR0 = 1;\n    I2C_init();\n    while(1) {\n        read_keys();\n        AD_Down = PCF_read(0x00);\n        AD_Up = PCF_read(0x01);\n        AD_Right = PCF_read(0x02);\n        AD_Left = PCF_read(0x03);\n        if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n            AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n        system_proc();\n        update_leds();\n    }\n}\n\nvoid timer0_isr() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n    stepper_ctrl();\n    system_error_blink();\n}\n---\n错误代码：\n---\n#include <reg51.h>\n#include <intrins.h>\n\n// 硬件引脚定义\nsbit SDA = P1^0;        // I2C数据线\nsbit SCL = P1^1;        // I2C时钟线\nsbit LED_MANUAL = P1^2; // 手动模式LED\nsbit LED_AUTO = P1^3;   // 自动模式LED\n\nsbit KEY_MODE = P3^5;   // 模式切换按键\nsbit KEY_UP = P3^0;     // 上方向键\nsbit KEY_DOWN = P3^1;   // 下方向键\nsbit KEY_LEFT = P3^2;   // 左方向键\nsbit KEY_RIGHT = P3^3;  // 右方向键\n\n// 全局变量定义\nunsigned char system_mode = 0;     // 0=手动模式, 1=自动模式\nunsigned char error_flag = 0;      // 异常标志\nunsigned char motor_step_v = 0;    // 垂直电机步进计数\nunsigned char motor_step_h = 0;    // 水平电机步进计数\nunsigned char timer_count = 0;     // 定时器计数\nunsigned char led_blink_count = 0; // LED闪烁计数\n\n// 光敏电阻数据\nunsigned char light_down = 0;   // AD0 下方光强\nunsigned char light_up = 0;     // AD1 上方光强  \nunsigned char light_right = 0;  // AD2 右方光强\nunsigned char light_left = 0;   // AD3 左方光强\n\n// 按键状态变量\nunsigned char key_state = 0xFF;\nunsigned char key_pressed = 0;\n\n// 步进电机相位表\nunsigned char code vertical_forward[8] = {0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09};\nunsigned char code vertical_reverse[8] = {0x09, 0x08, 0x0C, 0x04, 0x06, 0x02, 0x03, 0x01};\nunsigned char code horizontal_forward[8] = {0x10, 0x30, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x90};\nunsigned char code horizontal_reverse[8] = {0x90, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x30, 0x10};\n\n// 函数声明\nvoid system_init(void);\nvoid delay_ms(unsigned int ms);\nvoid delay_us(unsigned int us);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid i2c_ack(void);\nvoid i2c_nack(void);\nunsigned char i2c_wait_ack(void);\nvoid i2c_send_byte(unsigned char dat);\nunsigned char i2c_read_byte(void);\nunsigned char pcf8591_read(unsigned char channel);\nvoid scan_keys(void);\nvoid motor_control(unsigned char motor, unsigned char direction);\nvoid auto_tracking(void);\nvoid check_sensor_error(void);\nvoid update_led_status(void);\nvoid timer0_interrupt(void) interrupt 1;\n\n// 主函数\nvoid main(void)\n{\n    system_init();\n    \n    while(1)\n    {\n        // 读取光敏电阻数据\n        light_down = pcf8591_read(0);\n        light_up = pcf8591_read(1);\n        light_right = pcf8591_read(2);\n        light_left = pcf8591_read(3);\n        \n        // 检测传感器异常\n        check_sensor_error();\n        \n        // 按键扫描\n        scan_keys();\n        \n        // 模式处理\n        if(error_flag == 0)\n        {\n            if(system_mode == 1)  // 自动模式\n            {\n                auto_tracking();\n            }\n        }\n        \n        // 更新LED状态\n        update_led_status();\n        \n        delay_ms(10);  // 主循环延时\n    }\n}\n\n// 系统初始化\nvoid system_init(void)\n{\n    // 配置定时器0，2.5ms中断\n    TMOD = 0x01;        // 定时器0，16位模式\n    TH0 = 0xF3;         // 12MHz晶振，2.5ms装初值\n    TL0 = 0xCB;\n    ET0 = 1;            // 允许定时器0中断\n    TR0 = 1;            // 启动定时器0\n    EA = 1;             // 开总中断\n    \n    // 初始化I/O端口\n    P2 = 0x00;          // 电机控制端口初始化\n    LED_MANUAL = 1;     // 初始手动模式\n    LED_AUTO = 0;\n    \n    // 变量初始化\n    system_mode = 0;    // 默认手动模式\n    error_flag = 0;\n    motor_step_v = 0;\n    motor_step_h = 0;\n}\n\n// 延时函数\nvoid delay_ms(unsigned int ms)\n{\n    unsigned int i, j;\n    for(i = 0; i < ms; i++)\n        for(j = 0; j < 114; j++);  // 12MHz晶振，约1ms\n}\n\nvoid delay_us(unsigned int us)\n{\n    while(us--);\n}\n\n// I2C通信函数\nvoid i2c_start(void)\n{\n    SDA = 1;\n    SCL = 1;\n    delay_us(5);\n    SDA = 0;\n    delay_us(5);\n    SCL = 0;\n}\n\nvoid i2c_stop(void)\n{\n    SDA = 0;\n    SCL = 1;\n    delay_us(5);\n    SDA = 1;\n    delay_us(5);\n}\n\nvoid i2c_ack(void)\n{\n    SDA = 0;\n    delay_us(2);\n    SCL = 1;\n    delay_us(5);\n    SCL = 0;\n    delay_us(2);\n    SDA = 1;\n}\n\nvoid i2c_nack(void)\n{\n    SDA = 1;\n    delay_us(2);\n    SCL = 1;\n    delay_us(5);\n    SCL = 0;\n    delay_us(2);\n}\n\nunsigned char i2c_wait_ack(void)\n{\n    unsigned char ack_bit;\n    SDA = 1;\n    delay_us(2);\n    SCL = 1;\n    delay_us(2);\n    ack_bit = SDA;\n    delay_us(3);\n    SCL = 0;\n    delay_us(2);\n    return ack_bit;\n}\n\nvoid i2c_send_byte(unsigned char dat)\n{\n    unsigned char i;\n    for(i = 0; i < 8; i++)\n    {\n        if((dat << i) & 0x80)\n            SDA = 1;\n        else\n            SDA = 0;\n        delay_us(2);\n        SCL = 1;\n        delay_us(5);\n        SCL = 0;\n        delay_us(2);\n    }\n    SDA = 1;\n}\n\nunsigned char i2c_read_byte(void)\n{\n    unsigned char i, dat = 0;\n    SDA = 1;\n    for(i = 0; i < 8; i++)\n    {\n        dat <<= 1;\n        SCL = 1;\n        delay_us(2);\n        if(SDA)\n            dat |= 0x01;\n        delay_us(3);\n        SCL = 0;\n        delay_us(2);\n    }\n    return dat;\n}\n\n// PCF8591读取函数\nunsigned char pcf8591_read(unsigned char channel)\n{\n    unsigned char dat;\n    \n    i2c_start();\n    i2c_send_byte(0x90);    // PCF8591写地址\n    i2c_wait_ack();\n    i2c_send_byte(0x40 | channel);  // 选择通道\n    i2c_wait_ack();\n    i2c_start();\n    i2c_send_byte(0x91);    // PCF8591读地址\n    i2c_wait_ack();\n    dat = i2c_read_byte();  // 读取转换结果\n    i2c_nack();\n    i2c_stop();\n    \n    return dat;\n}\n\n// 按键扫描函数\nvoid scan_keys(void)\n{\n    unsigned char key_temp;\n    \n    key_temp = (P3 & 0x3F) | 0xC0;  // 读取按键状态\n    \n    if(key_temp != key_state)  // 按键状态变化\n    {\n        delay_ms(10);          // 消抖延时\n        key_temp = (P3 & 0x3F) | 0xC0;\n        \n        if(key_temp == key_state)\n            return;\n            \n        key_state = key_temp;\n        \n        // 检测按键按下\n        if(KEY_MODE == 0 && !(key_pressed & 0x20))  // 模式切换键\n        {\n            key_pressed |= 0x20;\n            system_mode = !system_mode;  // 切换模式\n        }\n        else if(KEY_MODE == 1)\n        {\n            key_pressed &= ~0x20;\n        }\n        \n        // 手动模式下的方向控制\n        if(system_mode == 0 && error_flag == 0)\n        {\n            if(KEY_UP == 0 && !(key_pressed & 0x01))\n            {\n                key_pressed |= 0x01;\n                motor_control(0, 1);  // 垂直电机正转\n            }\n            else if(KEY_UP == 1)\n            {\n                key_pressed &= ~0x01;\n            }\n            \n            if(KEY_DOWN == 0 && !(key_pressed & 0x02))\n            {\n                key_pressed |= 0x02;\n                motor_control(0, 0);  // 垂直电机反转\n            }\n            else if(KEY_DOWN == 1)\n            {\n                key_pressed &= ~0x02;\n            }\n            \n            if(KEY_LEFT == 0 && !(key_pressed & 0x04))\n            {\n                key_pressed |= 0x04;\n                motor_control(1, 0);  // 水平电机反转\n            }\n            else if(KEY_LEFT == 1)\n            {\n                key_pressed &= ~0x04;\n            }\n            \n            if(KEY_RIGHT == 0 && !(key_pressed & 0x08))\n            {\n                key_pressed |= 0x08;\n                motor_control(1, 1);  // 水平电机正转\n            }\n            else if(KEY_RIGHT == 1)\n            {\n                key_pressed &= ~0x08;\n            }\n        }\n    }\n}\n\n// 电机控制函数\nvoid motor_control(unsigned char motor, unsigned char direction)\n{\n    if(motor == 0)  // 垂直电机\n    {\n        if(direction == 1)  // 正转\n        {\n            P2 = (P2 & 0xF0) | vertical_forward[motor_step_v];\n            motor_step_v = (motor_step_v + 1) % 8;\n        }\n        else  // 反转\n        {\n            P2 = (P2 & 0xF0) | vertical_reverse[motor_step_v];\n            motor_step_v = (motor_step_v + 1) % 8;\n        }\n    }\n    else  // 水平电机\n    {\n        if(direction == 1)  // 正转\n        {\n            P2 = (P2 & 0x0F) | horizontal_forward[motor_step_h];\n            motor_step_h = (motor_step_h + 1) % 8;\n        }\n        else  // 反转\n        {\n            P2 = (P2 & 0x0F) | horizontal_reverse[motor_step_h];\n            motor_step_h = (motor_step_h + 1) % 8;\n        }\n    }\n}\n\n// 自动跟踪函数\nvoid auto_tracking(void)\n{\n    int diff_vertical, diff_horizontal;\n    \n    // 计算垂直方向光强差值\n    diff_vertical = (int)light_up - (int)light_down;\n    \n    // 计算水平方向光强差值 \n    diff_horizontal = (int)light_right - (int)light_left;\n    \n    // 垂直方向跟踪\n    if(diff_vertical >= 15)  // 上方光强更强\n    {\n        motor_control(0, 1);  // 垂直电机正转\n    }\n    else if(diff_vertical <= -15)  // 下方光强更强\n    {\n        motor_control(0, 0);  // 垂直电机反转\n    }\n    \n    // 水平方向跟踪\n    if(diff_horizontal >= 15)  // 右方光强更强\n    {\n        motor_control(1, 1);  // 水平电机正转\n    }\n    else if(diff_horizontal <= -15)  // 左方光强更强\n    {\n        motor_control(1, 0);  // 水平电机反转\n    }\n    \n    // 精确调整停止条件\n    if((diff_vertical > -4 && diff_vertical < 4) && \n       (diff_horizontal > -7 && diff_horizontal < 7))\n    {\n        // 光源对准，停止电机\n        P2 = 0x00;\n    }\n}\n\n// 传感器异常检测\nvoid check_sensor_error(void)\n{\n    if(light_down == 0 || light_down == 255 ||\n       light_up == 0 || light_up == 255 ||\n       light_right == 0 || light_right == 255 ||\n       light_left == 0 || light_left == 255)\n    {\n        error_flag = 1;  // 设置异常标志\n        P2 = 0x00;       // 停止电机\n    }\n    else\n    {\n        error_flag = 0;  // 清除异常标志\n    }\n}\n\n// LED状态更新\nvoid update_led_status(void)\n{\n    if(error_flag == 1)  // 异常状态\n    {\n        // 双LED闪烁\n        if(led_blink_count < 50)  // 1Hz闪烁，约500ms周期\n        {\n            LED_MANUAL = 0;\n            LED_AUTO = 0;\n        }\n        else\n        {\n            LED_MANUAL = 1;\n            LED_AUTO = 1;\n        }\n        \n        led_blink_count++;\n        if(led_blink_count >= 100)\n            led_blink_count = 0;\n    }\n    else  // 正常状态\n    {\n        if(system_mode == 0)  // 手动模式\n        {\n            LED_MANUAL = 1;\n            LED_AUTO = 0;\n        }\n        else  // 自动模式\n        {\n            LED_MANUAL = 0;\n            LED_AUTO = 1;\n        }\n    }\n}\n\n// 定时器0中断服务函数\nvoid timer0_interrupt(void) interrupt 1\n{\n    TH0 = 0xF3;  // 重装初值，2.5ms\n    TL0 = 0xCB;\n    \n    timer_count++;\n    \n    // 步进电机驱动时序控制\n    // 这里可以添加步进电机的时序控制逻辑\n    // 当前在按键和自动跟踪中直接控制电机\n}\n\n---"
  },
  {
    "role": "assistant",
    "content": "通过分析错误代码和三个参考代码，我发现错误代码存在多个关键问题，需要进行大幅修改以符合正确的设计模式。\n\n## 代码修改思路：\n\n**主要问题：**\n1. 按键引脚定义错误，与参考代码不匹配\n2. 电机控制逻辑错误，应在定时器中断中实现步进控制\n3. I2C通信逻辑复杂且错误，应简化并使用CY标志位\n4. 缺少正确的控制标志位和步进计数器\n5. LED闪烁逻辑和异常处理不正确\n\n## 解决方案：\n\n```c\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X = 0, DIR_Y = 0;\nuchar loop = 0, AD_Up = 0, AD_Down = 0, AD_Left = 0, AD_Right = 0, ms = 0, blink_ms = 0;\nbit Up_CB = 0, Down_CB = 0, Left_CB = 0, Right_CB = 0, SYS_mode = 0, SYS_ERROR = 0;\n\n// I2C通信函数\nvoid I2C_Delay() {;}\nvoid I2C_Start()  { SDA = 1; I2C_Delay(); SCL = 1; I2C_Delay(); SDA = 0; I2C_Delay(); }\nvoid I2C_Stop()   { SDA = 0; I2C_Delay(); SCL = 1; I2C_Delay(); SDA = 1; I2C_Delay(); }\nvoid I2C_Respons() { uchar i = 0; SCL = 1; I2C_Delay(); while((SDA==1)&&(i<250)) i++; SCL = 0; I2C_Delay(); }\nvoid I2C_Init()   { SDA = 1; I2C_Delay(); SCL = 1; I2C_Delay(); }\n\nuchar I2C_ReadByte() {\n    uchar i, k = 0;\n    SCL = 0; I2C_Delay(); SDA = 1; I2C_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; I2C_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; I2C_Delay();\n    }\n    return k;\n}\n\nvoid I2C_WriteByte(uchar date) {\n    uchar i, temp = date;\n    for (i = 0; i < 8; i++) {\n        temp <<= 1;\n        SCL = 0; I2C_Delay();\n        SDA = CY;\n        I2C_Delay();\n        SCL = 1; I2C_Delay();\n    }\n    SCL = 0; I2C_Delay(); SDA = 1; I2C_Delay();\n}\n\n// PCF8591读取函数\nuchar PCF8591_Read(uchar control) {\n    uchar date;\n    I2C_Start();\n    I2C_WriteByte(PCF8591); I2C_Respons();\n    I2C_WriteByte(control); I2C_Respons();\n    I2C_Start();\n    I2C_WriteByte(PCF8591+1); I2C_Respons();\n    date = I2C_ReadByte();\n    I2C_Stop();\n    return date;\n}\n\nvoid UTIL_Delay(uint T) { while(T--); }\n\n// 按键扫描函数\nvoid KEY_Scan() {\n    if (!key_state) {\n        UTIL_Delay(1000);\n        if (!key_state) {\n            while(!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n    if (!SYS_mode) {\n        if (!key_Up)      { Up_CB = 1; Down_CB = 0; }\n        else if (!key_Down) { Up_CB = 0; Down_CB = 1; }\n        else { Down_CB = 0; Up_CB = 0; }\n        if (!key_Left)      { Left_CB = 1; Right_CB = 0; }\n        else if (!key_Right) { Left_CB = 0; Right_CB = 1; }\n        else { Right_CB = 0; Left_CB = 0; }\n    }\n}\n\n// 自动跟踪处理函数\nvoid PROC_Run() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up-AD_Down>=Tol) Down_CB = 1;\n            else if (AD_Up-AD_Down<=4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down-AD_Up>=Tol) Up_CB = 1;\n            else if (AD_Down-AD_Up<=4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left-AD_Right>=Tol) Left_CB = 1;\n            else if (AD_Left-AD_Right<=7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right-AD_Left>=Tol) Right_CB = 1;\n            else if (AD_Right-AD_Left<=7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\n// LED状态更新函数\nvoid LED_Update() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) { led_1 = 0; led_2 = 1; }\n        else           { led_1 = 1; led_2 = 0; }\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01; TH0 = 0xf6; TL0 = 0x3b;\n    EA = 1; ET0 = 1; TR0 = 1;\n    I2C_Init();\n    while (1) {\n        KEY_Scan();\n        AD_Down = PCF8591_Read(0x00);\n        AD_Up   = PCF8591_Read(0x01);\n        AD_Right= PCF8591_Read(0x02);\n        AD_Left = PCF8591_Read(0x03);\n        if (AD_Down==255 || AD_Down==0 || AD_Up==255 || AD_Up==0 ||\n            AD_Right==255 || AD_Right==0 || AD_Left==255 || AD_Left==0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n        PROC_Run();\n        LED_Update();\n    }\n}\n\nvoid TIMER0_ISR() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n\n    if (Up_CB)\n        P2 = P2&0xf0 | FirstSet_FWD[loop];\n    else if (Down_CB)\n        P2 = P2&0xf0 | FirstSet_REV[loop];\n    else\n        P2 = P2&0xf0;\n\n    if (Left_CB)\n        P2 = P2&0x0f | Secondset_FWD[loop];\n    else if (Right_CB)\n        P2 = P2&0x0f | Secondset_REV[loop];\n    else\n        P2 = P2&0x0f;\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n```\n\n**关键修改点：**\n1. 统一按键引脚定义和变量命名与参考代码一致\n2. 使用正确的I2C通信函数，利用CY标志位进行数据传输\n3. 电机控制逻辑移至定时器中断，使用步进序列表驱动\n4. 采用统一的控制标志位系统(Up_CB, Down_CB等)\n5. 正确实现LED闪烁逻辑，异常时同步闪烁\n6. 简化主循环逻辑，专注于数据采集和处理"
  },
  {
    "role": "user",
    "content": "参考代码1：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[]    = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[]    = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[]   = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[]   = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\n//------------ I2C模块 ------------\nvoid PCF8591_Delay(void) {;}\n\nvoid I2C_Start(void) {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid I2C_Stop(void) {\n    SDA = 0; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid I2C_Response(void) {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid I2C_Init(void) {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n}\n\nuchar I2C_ReadByte(void) {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid I2C_WriteByte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay();\n        SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\n//------------ PCF8591模块 ------------\nvoid PCF8591_Write(uchar control, uchar value) { // 修正参数名\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(control);\n    I2C_Response();\n    I2C_WriteByte(value);\n    I2C_Response();\n    I2C_Stop();\n}\n\nuchar PCF8591_Read(uchar control) {\n    uchar result;\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(control);\n    I2C_Response();\n    I2C_Start();\n    I2C_WriteByte(PCF8591 + 1);\n    I2C_Response();\n    result = I2C_ReadByte();\n    I2C_Stop();\n    return result;\n}\n\nuchar PCF8591_DAC(uchar light) {\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(0x40);\n    I2C_Response();\n    I2C_WriteByte(light);\n    I2C_Response();\n    I2C_Stop();\n    return 1;\n}\n\n//------------ 控制与延时模块 ------------\nvoid DelayMs(uint T) {\n    while (T--);\n}\n\nvoid ManualKeyCheck(void) {\n    if (!key_state) {\n        DelayMs(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid AutoCtrlProc(void) {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid SystemErrorCheck(void) {\n    if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n        AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n        SYS_ERROR = 1;\n    } else {\n        SYS_ERROR = 0;\n    }\n}\n\nvoid LEDUpdate(void) {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) {\n            led_1 = 0; led_2 = 1;\n        } else {\n            led_1 = 1; led_2 = 0;\n        }\n    }\n}\n\n//------------ 主函数与中断服务 ------------\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    I2C_Init();\n\n    while (1) {\n        ManualKeyCheck();\n        AD_Down = PCF8591_Read(0x00);\n        AD_Up = PCF8591_Read(0x01);\n        AD_Right = PCF8591_Read(0x02);\n        AD_Left = PCF8591_Read(0x03);\n\n        SystemErrorCheck();\n        AutoCtrlProc();\n        LEDUpdate();\n    }\n}\n\nvoid Timer0_ISR(void) interrupt 1 {\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n\n    if (Up_CB) {\n        P2 = (P2 & 0xf0) | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = (P2 & 0xf0) | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = (P2 & 0x0f) | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = (P2 & 0x0f) | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n---\n参考代码2：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\nvoid PCF8591_Delay() {;}\n\nvoid start() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid stop() {\n    SDA = 0; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid respons() {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid init() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n}\n\nuchar read_byte() {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid write_byte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay();\n        SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid write_add(uchar control, uchar date) {\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    write_byte(date);\n    respons();\n    stop();\n}\n\nuchar read_add(uchar control) {\n    uchar date;\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    start();\n    write_byte(PCF8591 + 1);\n    respons();\n    date = read_byte();\n    stop();\n    return date;\n}\n\nuchar DAC(uchar light) {\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(0x40);\n    respons();\n    write_byte(light);\n    respons();\n    stop();\n    return 1;\n}\n\nvoid delay(uint T) {\n    while (T--);\n}\n\nvoid key() {\n    if (!key_state) {\n        delay(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid proc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    init();\n\n    while (1) {\n        key();\n        AD_Down = read_add(0x00);\n        AD_Up = read_add(0x01);\n        AD_Right = read_add(0x02);\n        AD_Left = read_add(0x03);\n\n        if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 || AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n\n        proc();\n        if (SYS_ERROR == 0) {\n            if (!SYS_mode) {\n                led_1 = 0; led_2 = 1;\n            } else {\n                led_1 = 1; led_2 = 0;\n            }\n        }\n    }\n}\n\nvoid init_1() interrupt 1 {\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n---\n参考代码3：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\nvoid pcf_delay() {\n    ;\n}\n\nvoid i2c_start() {\n    SDA = 1; pcf_delay();\n    SCL = 1; pcf_delay();\n    SDA = 0; pcf_delay();\n}\n\nvoid i2c_stop() {\n    SDA = 0; pcf_delay();\n    SCL = 1; pcf_delay();\n    SDA = 1; pcf_delay();\n}\n\nvoid i2c_resp() {\n    uchar i = 0;\n    SCL = 1; pcf_delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; pcf_delay();\n}\n\nvoid i2c_init() {\n    SDA = 1; pcf_delay();\n    SCL = 1; pcf_delay();\n}\n\nuchar i2c_readbyte() {\n    uchar i, k = 0;\n    SCL = 0; pcf_delay();\n    SDA = 1; pcf_delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; pcf_delay();\n        k = (k << 1) | SDA;\n        SCL = 0; pcf_delay();\n    }\n    return k;\n}\n\nvoid i2c_writebyte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; pcf_delay();\n        SDA = CY; pcf_delay();\n        SCL = 1; pcf_delay();\n    }\n    SCL = 0; pcf_delay();\n    SDA = 1; pcf_delay();\n}\n\nuchar read_sensor(uchar channel) {\n    uchar d;\n    i2c_start();\n    i2c_writebyte(PCF8591); i2c_resp();\n    i2c_writebyte(channel); i2c_resp();\n    i2c_start();\n    i2c_writebyte(PCF8591 + 1); i2c_resp();\n    d = i2c_readbyte();\n    i2c_stop();\n    return d;\n}\n\nuchar write_dac(uchar light) {\n    i2c_start();\n    i2c_writebyte(PCF8591); i2c_resp();\n    i2c_writebyte(0x40); i2c_resp();\n    i2c_writebyte(light); i2c_resp();\n    i2c_stop();\n    return 1;\n}\n\nvoid wait(uint t) {\n    while (t--);\n}\n\nvoid check_key() {\n    if (!key_state) {\n        wait(1000);\n        if (!key_state) {\n            while (!key_state)\n                Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid auto_control() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid check_sys_err() {\n    if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n        AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0)\n        SYS_ERROR = 1;\n    else\n        SYS_ERROR = 0;\n}\n\nvoid update_led() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) {\n            led_1 = 0; led_2 = 1;\n        } else {\n            led_1 = 1; led_2 = 0;\n        }\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    i2c_init();\n\n    while (1) {\n        check_key();\n        AD_Down = read_sensor(0x00);\n        AD_Up = read_sensor(0x01);\n        AD_Right = read_sensor(0x02);\n        AD_Left = read_sensor(0x03);\n        check_sys_err();\n        auto_control();\n        update_led();\n    }\n}\n\nvoid timer0_proc() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n---\n错误代码：\n---\n#include <reg51.h>\n\n// 硬件引脚定义\nsbit SDA = P1^0;        // I2C数据线\nsbit SCL = P1^1;        // I2C时钟线\nsbit LED_MANUAL = P1^2; // 手动模式LED\nsbit LED_AUTO = P1^3;   // 自动模式LED\n\nsbit KEY_MODE = P3^5;   // 模式切换按键\nsbit KEY_UP = P3^0;     // 上键\nsbit KEY_DOWN = P3^1;   // 下键\nsbit KEY_LEFT = P3^2;   // 左键\nsbit KEY_RIGHT = P3^3;  // 右键\n\n// 全局变量定义\nunsigned char mode = 0;              // 0=手动模式, 1=自动模式\nunsigned char sensor_error = 0;     // 传感器错误标志\nunsigned char light_values[4];      // 光敏电阻值数组\nunsigned char step_phase_v = 0;     // 垂直电机相位\nunsigned char step_phase_h = 0;     // 水平电机相位\nunsigned char timer_count = 0;      // 定时器计数\nunsigned char led_flash_count = 0;  // LED闪烁计数\n\n// 步进电机相位表\nunsigned char code vertical_forward[] = {0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09};\nunsigned char code vertical_backward[] = {0x09, 0x08, 0x0C, 0x04, 0x06, 0x02, 0x03, 0x01};\nunsigned char code horizontal_forward[] = {0x10, 0x30, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x90};\nunsigned char code horizontal_backward[] = {0x90, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x30, 0x10};\n\n// 函数声明\nvoid system_init(void);\nvoid delay_us(unsigned char us);\nvoid delay_ms(unsigned char ms);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid i2c_write_byte(unsigned char dat);\nunsigned char i2c_read_byte(void);\nunsigned char read_adc_channel(unsigned char channel);\nvoid read_all_sensors(void);\nvoid check_sensor_error(void);\nvoid scan_keys(void);\nvoid motor_control(unsigned char direction);\nvoid auto_tracking(void);\nvoid update_led_status(void);\nvoid timer0_isr(void) interrupt 1;\n\n// 系统初始化\nvoid system_init(void) {\n    // 配置定时器0 (2.5ms中断)\n    TMOD = 0x01;    // 定时器0工作模式1\n    TH0 = 0xF6;     // 12MHz晶振下2.5ms定时初值\n    TL0 = 0x3C;\n    ET0 = 1;        // 使能定时器0中断\n    TR0 = 1;        // 启动定时器0\n    EA = 1;         // 开总中断\n    \n    // 初始化I/O口\n    P2 = 0x00;      // 步进电机控制口清零\n    LED_MANUAL = 1; // 默认手动模式\n    LED_AUTO = 0;\n    \n    mode = 0;       // 默认手动模式\n    sensor_error = 0;\n}\n\n// 微秒级延时\nvoid delay_us(unsigned char us) {\n    while(us--) {\n        _nop_();\n        _nop_();\n    }\n}\n\n// 毫秒级延时\nvoid delay_ms(unsigned char ms) {\n    unsigned char i;\n    while(ms--) {\n        for(i = 0; i < 120; i++) {\n            delay_us(1);\n        }\n    }\n}\n\n// I2C起始信号\nvoid i2c_start(void) {\n    SDA = 1;\n    SCL = 1;\n    delay_us(5);\n    SDA = 0;\n    delay_us(5);\n    SCL = 0;\n}\n\n// I2C停止信号\nvoid i2c_stop(void) {\n    SDA = 0;\n    SCL = 1;\n    delay_us(5);\n    SDA = 1;\n    delay_us(5);\n}\n\n// I2C写字节\nvoid i2c_write_byte(unsigned char dat) {\n    unsigned char i;\n    for(i = 0; i < 8; i++) {\n        SCL = 0;\n        delay_us(2);\n        SDA = (dat & 0x80) ? 1 : 0;\n        dat <<= 1;\n        delay_us(2);\n        SCL = 1;\n        delay_us(5);\n    }\n    SCL = 0;\n    delay_us(2);\n    SDA = 1;\n    delay_us(2);\n    SCL = 1;\n    delay_us(5);\n    SCL = 0;\n}\n\n// I2C读字节\nunsigned char i2c_read_byte(void) {\n    unsigned char i, dat = 0;\n    SDA = 1;\n    for(i = 0; i < 8; i++) {\n        SCL = 0;\n        delay_us(5);\n        SCL = 1;\n        delay_us(2);\n        dat <<= 1;\n        if(SDA) dat |= 0x01;\n        delay_us(3);\n    }\n    SCL = 0;\n    delay_us(2);\n    SDA = 0;  // ACK\n    delay_us(2);\n    SCL = 1;\n    delay_us(5);\n    SCL = 0;\n    return dat;\n}\n\n// 读取ADC指定通道\nunsigned char read_adc_channel(unsigned char channel) {\n    unsigned char result;\n    \n    i2c_start();\n    i2c_write_byte(0x90);  // PCF8591写地址\n    i2c_write_byte(0x40 | channel);  // 通道选择\n    i2c_stop();\n    \n    delay_ms(1);  // 转换延时\n    \n    i2c_start();\n    i2c_write_byte(0x91);  // PCF8591读地址\n    result = i2c_read_byte();\n    i2c_stop();\n    \n    return result;\n}\n\n// 读取所有传感器数据\nvoid read_all_sensors(void) {\n    light_values[0] = read_adc_channel(0);  // 下方\n    light_values[1] = read_adc_channel(1);  // 上方\n    light_values[2] = read_adc_channel(2);  // 右方\n    light_values[3] = read_adc_channel(3);  // 左方\n}\n\n// 检查传感器异常\nvoid check_sensor_error(void) {\n    unsigned char i, error_flag = 0;\n    \n    for(i = 0; i < 4; i++) {\n        if(light_values[i] == 0 || light_values[i] == 255) {\n            error_flag = 1;\n            break;\n        }\n    }\n    \n    sensor_error = error_flag;\n}\n\n// 按键扫描\nvoid scan_keys(void) {\n    static unsigned char key_state = 0xFF;\n    unsigned char current_keys;\n    \n    // 读取按键状态\n    current_keys = (P3 & 0x3F) | ((KEY_MODE == 0) ? 0x00 : 0x20);\n    \n    // 按键去抖处理\n    if(current_keys != key_state) {\n        delay_ms(10);\n        current_keys = (P3 & 0x3F) | ((KEY_MODE == 0) ? 0x00 : 0x20);\n        \n        if(current_keys == key_state) {\n            return;\n        }\n        \n        // 模式切换键\n        if((key_state & 0x20) && !(current_keys & 0x20)) {\n            mode = !mode;\n        }\n        \n        // 手动控制键（仅在手动模式下有效）\n        if(mode == 0 && sensor_error == 0) {\n            if((key_state & 0x01) && !(current_keys & 0x01)) {\n                motor_control(1);  // 上\n            }\n            if((key_state & 0x02) && !(current_keys & 0x02)) {\n                motor_control(2);  // 下\n            }\n            if((key_state & 0x04) && !(current_keys & 0x04)) {\n                motor_control(3);  // 左\n            }\n            if((key_state & 0x08) && !(current_keys & 0x08)) {\n                motor_control(4);  // 右\n            }\n        }\n        \n        key_state = current_keys;\n    }\n}\n\n// 电机控制\nvoid motor_control(unsigned char direction) {\n    unsigned char motor_code = 0;\n    \n    switch(direction) {\n        case 1: // 上 - 垂直正转\n            motor_code = vertical_forward[step_phase_v];\n            step_phase_v++;\n            if(step_phase_v >= 8) step_phase_v = 0;\n            break;\n            \n        case 2: // 下 - 垂直反转\n            motor_code = vertical_backward[step_phase_v];\n            step_phase_v++;\n            if(step_phase_v >= 8) step_phase_v = 0;\n            break;\n            \n        case 3: // 左 - 水平反转\n            motor_code = horizontal_backward[step_phase_h];\n            step_phase_h++;\n            if(step_phase_h >= 8) step_phase_h = 0;\n            break;\n            \n        case 4: // 右 - 水平正转\n            motor_code = horizontal_forward[step_phase_h];\n            step_phase_h++;\n            if(step_phase_h >= 8) step_phase_h = 0;\n            break;\n            \n        default:\n            return;\n    }\n    \n    P2 = motor_code;\n    delay_ms(3);  // 确保步进电机稳定转动\n}\n\n// 自动跟踪算法\nvoid auto_tracking(void) {\n    signed char diff_vertical, diff_horizontal;\n    \n    if(mode != 1 || sensor_error != 0) {\n        return;\n    }\n    \n    // 计算垂直方向光强差值 (上方 - 下方)\n    diff_vertical = (signed char)light_values[1] - (signed char)light_values[0];\n    \n    // 计算水平方向光强差值 (右方 - 左方)\n    diff_horizontal = (signed char)light_values[2] - (signed char)light_values[3];\n    \n    // 垂直方向调整\n    if(diff_vertical >= 15) {\n        motor_control(1);  // 向上调整\n    } else if(diff_vertical <= -15) {\n        motor_control(2);  // 向下调整\n    }\n    \n    // 水平方向调整\n    if(diff_horizontal >= 15) {\n        motor_control(4);  // 向右调整\n    } else if(diff_horizontal <= -15) {\n        motor_control(3);  // 向左调整\n    }\n}\n\n// 更新LED状态\nvoid update_led_status(void) {\n    if(sensor_error) {\n        // 异常状态 - 双LED闪烁 (1Hz)\n        if(led_flash_count >= 100) {  // 约1秒\n            LED_MANUAL = !LED_MANUAL;\n            LED_AUTO = LED_MANUAL;\n            led_flash_count = 0;\n        }\n    } else {\n        // 正常状态 - 根据模式显示\n        if(mode == 0) {\n            LED_MANUAL = 1;\n            LED_AUTO = 0;\n        } else {\n            LED_MANUAL = 0;\n            LED_AUTO = 1;\n        }\n    }\n}\n\n// 定时器0中断服务程序 (2.5ms)\nvoid timer0_isr(void) interrupt 1 {\n    TH0 = 0xF6;  // 重装初值\n    TL0 = 0x3C;\n    \n    timer_count++;\n    led_flash_count++;\n    \n    // 每10ms执行一次传感器读取和处理\n    if(timer_count >= 4) {\n        timer_count = 0;\n        \n        // 读取传感器数据\n        read_all_sensors();\n        \n        // 检查传感器异常\n        check_sensor_error();\n        \n        // 自动跟踪处理\n        if(mode == 1) {\n            auto_tracking();\n        }\n    }\n}\n\n// 主程序\nvoid main(void) {\n    // 系统初始化\n    system_init();\n    \n    // 主循环\n    while(1) {\n        // 按键扫描\n        scan_keys();\n        \n        // 更新LED状态\n        update_led_status();\n        \n        // 短暂延时\n        delay_ms(10);\n    }\n}\n\n---"
  },
  {
    "role": "assistant",
    "content": "通过分析错误代码和三个参考代码，我发现错误代码存在多个关键问题，需要进行全面修改以符合正确的设计模式。\n\n## 代码修改思路：\n\n**主要问题：**\n1. 头文件错误（使用了reg51.h而非reg52.h）\n2. 按键引脚定义与参考代码不匹配\n3. 变量命名不统一，缺少关键的控制标志位\n4. I2C通信协议实现错误，没有使用CY标志位\n5. 电机控制逻辑错误，应在定时器中断中统一控制\n6. 按键处理逻辑过于复杂\n7. LED闪烁机制不正确\n\n## 解决方案：\n\n```c\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\n// I2C通信函数\nvoid PCF8591_Delay() {;}\n\nvoid I2C_Start() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid I2C_Stop() {\n    SDA = 0; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid I2C_Response() {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid I2C_Init() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n}\n\nuchar I2C_ReadByte() {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid I2C_WriteByte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay();\n        SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\n// PCF8591读取函数\nuchar PCF8591_Read(uchar control) {\n    uchar result;\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(control);\n    I2C_Response();\n    I2C_Start();\n    I2C_WriteByte(PCF8591 + 1);\n    I2C_Response();\n    result = I2C_ReadByte();\n    I2C_Stop();\n    return result;\n}\n\nvoid DelayMs(uint T) {\n    while (T--);\n}\n\n// 按键扫描函数\nvoid ManualKeyCheck() {\n    if (!key_state) {\n        DelayMs(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\n// 自动跟踪处理函数\nvoid AutoCtrlProc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\n// 系统异常检测\nvoid SystemErrorCheck() {\n    if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n        AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n        SYS_ERROR = 1;\n    } else {\n        SYS_ERROR = 0;\n    }\n}\n\n// LED状态更新\nvoid LEDUpdate() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) {\n            led_1 = 0; led_2 = 1;\n        } else {\n            led_1 = 1; led_2 = 0;\n        }\n    }\n}\n\n// 主函数\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    I2C_Init();\n\n    while (1) {\n        ManualKeyCheck();\n        AD_Down = PCF8591_Read(0x00);\n        AD_Up = PCF8591_Read(0x01);\n        AD_Right = PCF8591_Read(0x02);\n        AD_Left = PCF8591_Read(0x03);\n\n        SystemErrorCheck();\n        AutoCtrlProc();\n        LEDUpdate();\n    }\n}\n\n// 定时器0中断服务函数\nvoid Timer0_ISR() interrupt 1 {\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n\n    if (Up_CB) {\n        P2 = (P2 & 0xf0) | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = (P2 & 0xf0) | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = (P2 & 0x0f) | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = (P2 & 0x0f) | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n```\n\n**关键修改点：**\n1. 修正头文件为reg52.h，统一按键引脚定义\n2. 使用统一的变量命名体系和控制标志位\n3. 实现正确的I2C通信协议，使用CY标志位进行数据传输\n4. 将电机控制逻辑完全移至定时器中断中，使用步进序列表\n5. 简化按键处理逻辑，去除复杂的状态机\n6. 实现正确的LED闪烁机制，异常时双LED同步闪烁\n7. 统一函数命名风格，提高代码可读性"
  }
]