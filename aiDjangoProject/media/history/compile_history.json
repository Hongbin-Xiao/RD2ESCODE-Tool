[
  {
    "role": "system",
    "content": "You will act as an experienced embedded systems design engineer, implementing an embedded system through code based on the given requirements document.Between the two---below is a requirements document，Based on this information, first generate the steps required to build the system and the complete C code, implementing each functional part step by step.The following are the notes for generating the code:\n1.It is forbidden to use data as a parameter.\n2.The code compiler is Keil uVision5.\n3.Assume that there are no known driver files.\n4.The designed code must implement all functions.\n5.The final output of the complete code must be in C language format, specifically:```code your code```，where your code is the complete C code."
  },
  {
    "role": "user",
    "content": "Requirements document：\n---\n需求文档：基于8051单片机的太阳能自动跟踪系统\n1. 项目概述\n本系统基于8051系列单片机（如AT89C51）设计，通过光敏电阻传感器检测环境光照强度，实现太阳能板的自动跟踪控制。系统支持手动与自动双模式运行，能够根据光源方向调整太阳能板的水平和垂直角度，最大化光能吸收效率。核心功能包括传感器数据采集、步进电机驱动、异常状态指示及人机交互控制，适用于太阳能发电设备的光源追踪场景。\n\n2. 功能需求\n功能编号\t功能描述\t输入/触发条件\t输出/响应结果\nF1\t手动/自动模式切换\t按下模式切换按键（P3.5）\t切换LED指示灯（P1.2/P1.3）状态\nF2\t手动方向控制\t按下方向按键（上下左右）\t步进电机按指定方向转动\nF3\t自动光源跟踪\t自动模式下光敏电阻输入\t步进电机自动调整至光源最强方向\nF4\t传感器异常检测\t光敏电阻值超限（0或255）\tLED双灯闪烁提示错误\nF5\t步进电机驱动控制\t方向标志位触发\t步进电机按预设相位序列转动\nF6\t系统状态显示\t实时运行中\tLED指示当前模式（手动/自动/异常）\n3. 非功能需求\n性能指标\n\n跟踪精度：光强差值容错范围±15（可配置），差值小于4（垂直）/7（水平）时停止微调。\n\n响应速度：步进电机驱动周期2.5ms，确保转动平滑无抖动。\n\n传感器采样率：ADC数据每秒更新≥100次。\n\n异常恢复：传感器恢复正常后，系统自动退出错误状态。\n\n硬件约束\n\n主控芯片：AT89C51单片机，12MHz晶振。\n\n传感器模块：4路光敏电阻（连接PCF8591 ADC芯片），检测范围0-5V。\n\n执行机构：2路四相步进电机，分别控制水平和垂直方向。\n\n人机接口：5个独立按键（模式切换、上下左右控制），2个LED状态指示灯。\n\n可靠性要求\n\n工作温度范围：-20℃~70℃。\n\n持续运行时间：≥24×7小时。\n\n抗干扰设计：光敏电阻输入信号需经RC滤波，按键硬件去抖。\n\n4. 系统设计\n4.1 硬件设计\n模块\t配置说明\n主控电路\tAT89C51最小系统（含复位电路、12MHz晶振）\nADC模块\tPCF8591芯片，I2C接口（SDA→P1.0, SCL→P1.1）\n步进电机驱动\t水平方向电机接P2.0-P2.3，垂直方向接P2.4-P2.7\n传感器输入\t4路光敏电阻连接PCF8591通道0-3（AD0-AD3）\n状态指示\t手动模式LED（P1.2），自动模式LED（P1.3）\n4.2 软件设计\n主程序流程\n\nplaintext\n复制\n初始化 → 配置定时器、ADC → 进入主循环:  \n  1. 读取光敏电阻值（AD0-AD3）  \n  2. 检测按键输入，切换模式或方向  \n  3. 执行自动跟踪逻辑（差值计算与方向决策）  \n  4. 更新步进电机控制信号  \n  5. 检测传感器异常并触发告警  \n关键逻辑\n\n自动跟踪算法：\n\n垂直方向：比较上下光敏电阻值（AD0 vs AD1），差值≥15时调整电机方向。\n\n水平方向：比较左右光敏电阻值（AD2 vs AD3），差值≥15时调整电机方向。\n\n步进电机控制：\n\n使用8相位驱动序列（如0x01, 0x03, 0x02…），通过定时器中断（2.5ms）循环输出。\n\n异常处理：\n\n光敏电阻值超出0-255范围时，双LED以1Hz频率闪烁告警。\n\n5. 测试验证\n测试项\t预期结果\t通过标准\n手动模式控制\t按键按下后步进电机按预期方向转动\t电机转动方向与按键定义一致\n自动模式光源跟踪\t光源偏移后电机自动调整至对准位置\t调整时间≤2秒，停止后光强差值<4\n传感器异常检测\t光敏电阻短路/开路\t双LED闪烁，电机停止运行\n模式切换响应\t按下模式键后LED状态切换\t手动/自动模式指示正确\n步进电机驱动稳定性\t连续运行1小时\t无丢步、过热现象\n6. 依赖项\n硬件依赖\n\nPCF8591 ADC模块、四相步进电机、光敏电阻阵列、5V稳压电源。\n\n软件依赖\n\nKeil C51开发环境，支持8051指令集及定时器中断配置。\n\n\n附录\n光敏电阻布局\n\n传感器\t功能\tPCF8591通道\nAD0\t下方光强检测\t通道0\nAD1\t上方光强检测\t通道1\nAD2\t右方光强检测\t通道2\nAD3\t左方光强检测\t通道3\n步进电机相位表\n\n方向\t控制码序列（16进制）\n垂直正转\t0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09\n垂直反转\t0x09, 0x08, 0x0C, 0x04, 0x06, 0x02, 0x03, 0x01\n水平正转\t0x10, 0x30, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x90\n水平反转\t0x90, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x30, 0x10\n\n---"
  },
  {
    "role": "user",
    "content": "The C code you generated earlier failed to compile in Keil uVision5. Please revise your code according to the following compiler feedback and output as required:###\\Revised C Code###\n```code your code```\nCompiler feedback：\nC51 COMPILER V9.59.0.0 - SN: T1DZC-JTZ2TC\nCOPYRIGHT Copyright (C) 2012 - 2018 ARM Ltd and ARM Germany GmbH. All rights reserved.\n*** ERROR C141 IN LINE 45 OF C:/Users/12240/Desktop/ai-project/aiDjangoProject/media/output/TESToutput.c: syntax error near ';', expected 'hdata'\n\nC51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)\n\n"
  },
  {
    "role": "assistant",
    "content": "Looking at the compiler error, it appears there's a syntax issue near line 45. Let me analyze the requirements and provide a corrected implementation.\n\n### Revised C Code ###\n\n```c\n#include <reg51.h>\n\n// Pin definitions\nsbit SDA = P1^0;        // I2C Data line\nsbit SCL = P1^1;        // I2C Clock line\nsbit LED_MANUAL = P1^2; // Manual mode LED\nsbit LED_AUTO = P1^3;   // Auto mode LED\nsbit KEY_MODE = P3^5;   // Mode switch key\nsbit KEY_UP = P3^0;     // Up direction key\nsbit KEY_DOWN = P3^1;   // Down direction key\nsbit KEY_LEFT = P3^2;   // Left direction key\nsbit KEY_RIGHT = P3^3;  // Right direction key\n\n// Global variables\nunsigned char system_mode = 0;  // 0=manual, 1=auto\nunsigned char motor_step_v = 0; // Vertical motor step\nunsigned char motor_step_h = 0; // Horizontal motor step\nunsigned char sensor_data[4];   // AD0-AD3 sensor values\nbit error_flag = 0;             // Error status flag\nunsigned char timer_count = 0;  // Timer counter\nbit led_blink_state = 0;        // LED blink state\n\n// Step sequences for motors\nunsigned char code v_motor_forward[8] = {0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09};\nunsigned char code v_motor_backward[8] = {0x09, 0x08, 0x0C, 0x04, 0x06, 0x02, 0x03, 0x01};\nunsigned char code h_motor_forward[8] = {0x10, 0x30, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x90};\nunsigned char code h_motor_backward[8] = {0x90, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x30, 0x10};\n\n// Function prototypes\nvoid system_init(void);\nvoid timer0_init(void);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid i2c_send_byte(unsigned char dat);\nunsigned char i2c_read_byte(void);\nvoid i2c_ack(void);\nvoid i2c_nack(void);\nunsigned char pcf8591_read(unsigned char channel);\nvoid read_sensors(void);\nvoid key_scan(void);\nvoid auto_tracking(void);\nvoid motor_control(void);\nvoid error_check(void);\nvoid led_update(void);\nvoid delay_ms(unsigned int ms);\n\n// Main function\nvoid main(void)\n{\n    system_init();\n    timer0_init();\n    \n    while(1)\n    {\n        read_sensors();\n        key_scan();\n        error_check();\n        \n        if(!error_flag)\n        {\n            if(system_mode == 1) // Auto mode\n            {\n                auto_tracking();\n            }\n            motor_control();\n        }\n        \n        led_update();\n        delay_ms(10);\n    }\n}\n\n// System initialization\nvoid system_init(void)\n{\n    P1 = 0xFF; // Initialize P1\n    P2 = 0x00; // Motor control port\n    P3 = 0xFF; // Key input port\n    \n    LED_MANUAL = 1; // Manual mode LED on\n    LED_AUTO = 0;   // Auto mode LED off\n    system_mode = 0; // Start in manual mode\n    \n    EA = 1; // Enable global interrupts\n}\n\n// Timer0 initialization (2.5ms interrupt)\nvoid timer0_init(void)\n{\n    TMOD = 0x01; // Timer0 mode 1 (16-bit)\n    TH0 = 0xF6;  // High byte for 2.5ms at 12MHz\n    TL0 = 0x3C;  // Low byte\n    ET0 = 1;     // Enable Timer0 interrupt\n    TR0 = 1;     // Start Timer0\n}\n\n// Timer0 interrupt service routine\nvoid timer0_isr(void) interrupt 1\n{\n    TH0 = 0xF6; // Reload timer values\n    TL0 = 0x3C;\n    \n    timer_count++;\n    if(timer_count >= 100) // 250ms for LED blink\n    {\n        timer_count = 0;\n        led_blink_state = !led_blink_state;\n    }\n}\n\n// I2C communication functions\nvoid i2c_start(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SDA = 0;\n    SCL = 0;\n}\n\nvoid i2c_stop(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SDA = 1;\n}\n\nvoid i2c_send_byte(unsigned char dat)\n{\n    unsigned char i;\n    for(i = 0; i < 8; i++)\n    {\n        SDA = (dat & 0x80) ? 1 : 0;\n        dat <<= 1;\n        SCL = 1;\n        SCL = 0;\n    }\n}\n\nunsigned char i2c_read_byte(void)\n{\n    unsigned char i, dat = 0;\n    SDA = 1;\n    for(i = 0; i < 8; i++)\n    {\n        SCL = 1;\n        dat <<= 1;\n        if(SDA) dat |= 0x01;\n        SCL = 0;\n    }\n    return dat;\n}\n\nvoid i2c_ack(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SCL = 0;\n}\n\nvoid i2c_nack(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SCL = 0;\n}\n\n// Read PCF8591 ADC channel\nunsigned char pcf8591_read(unsigned char channel)\n{\n    unsigned char dat;\n    \n    i2c_start();\n    i2c_send_byte(0x90); // PCF8591 write address\n    i2c_ack();\n    i2c_send_byte(channel); // Channel select\n    i2c_ack();\n    \n    i2c_start();\n    i2c_send_byte(0x91); // PCF8591 read address\n    i2c_ack();\n    dat = i2c_read_byte();\n    i2c_nack();\n    i2c_stop();\n    \n    return dat;\n}\n\n// Read all sensor values\nvoid read_sensors(void)\n{\n    sensor_data[0] = pcf8591_read(0); // Down sensor (AD0)\n    sensor_data[1] = pcf8591_read(1); // Up sensor (AD1)\n    sensor_data[2] = pcf8591_read(2); // Right sensor (AD2)\n    sensor_data[3] = pcf8591_read(3); // Left sensor (AD3)\n}\n\n// Key scanning function\nvoid key_scan(void)\n{\n    static unsigned char key_state = 0xFF;\n    unsigned char key_current;\n    \n    key_current = (P3 & 0x3F); // Read keys P3.0-P3.5\n    \n    // Mode switch key (P3.5)\n    if((key_state & 0x20) && !(key_current & 0x20))\n    {\n        system_mode = !system_mode;\n        delay_ms(20); // Debounce\n    }\n    \n    // Manual mode direction keys\n    if(system_mode == 0) // Manual mode\n    {\n        if(!(key_current & 0x01)) // UP key\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            P2 = (P2 & 0x0F) | (v_motor_forward[motor_step_v] << 4);\n        }\n        else if(!(key_current & 0x02)) // DOWN key\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            P2 = (P2 & 0x0F) | (v_motor_backward[motor_step_v] << 4);\n        }\n        else if(!(key_current & 0x04)) // LEFT key\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            P2 = (P2 & 0xF0) | h_motor_backward[motor_step_h];\n        }\n        else if(!(key_current & 0x08)) // RIGHT key\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            P2 = (P2 & 0xF0) | h_motor_forward[motor_step_h];\n        }\n    }\n    \n    key_state = key_current;\n}\n\n// Auto tracking algorithm\nvoid auto_tracking(void)\n{\n    int diff_v, diff_h;\n    \n    // Vertical tracking (Up vs Down)\n    diff_v = (int)sensor_data[1] - (int)sensor_data[0];\n    \n    if(diff_v >= 15) // Move up\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        P2 = (P2 & 0x0F) | (v_motor_forward[motor_step_v] << 4);\n    }\n    else if(diff_v <= -15) // Move down\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        P2 = (P2 & 0x0F) | (v_motor_backward[motor_step_v] << 4);\n    }\n    \n    // Horizontal tracking (Left vs Right)\n    diff_h = (int)sensor_data[3] - (int)sensor_data[2];\n    \n    if(diff_h >= 15) // Move left\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        P2 = (P2 & 0xF0) | h_motor_backward[motor_step_h];\n    }\n    else if(diff_h <= -15) // Move right\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        P2 = (P2 & 0xF0) | h_motor_forward[motor_step_h];\n    }\n}\n\n// Motor control function\nvoid motor_control(void)\n{\n    // Motor control is handled in key_scan and auto_tracking functions\n    // This function can be used for additional motor control logic if needed\n}\n\n// Error checking function\nvoid error_check(void)\n{\n    unsigned char i;\n    error_flag = 0;\n    \n    // Check if any sensor value is 0 or 255 (abnormal)\n    for(i = 0; i < 4; i++)\n    {\n        if(sensor_data[i] == 0 || sensor_data[i] == 255)\n        {\n            error_flag = 1;\n            break;\n        }\n    }\n}\n\n// LED status update\nvoid led_update(void)\n{\n    if(error_flag)\n    {\n        // Error state: both LEDs blink\n        LED_MANUAL = led_blink_state;\n        LED_AUTO = led_blink_state;\n    }\n    else\n    {\n        // Normal operation\n        if(system_mode == 0) // Manual mode\n        {\n            LED_MANUAL = 1;\n            LED_AUTO = 0;\n        }\n        else // Auto mode\n        {\n            LED_MANUAL = 0;\n            LED_AUTO = 1;\n        }\n    }\n}\n\n// Simple delay function\nvoid delay_ms(unsigned int ms)\n{\n    unsigned int i, j;\n    for(i = 0; i < ms; i++)\n    {\n        for(j = 0; j < 110; j++)\n        {\n            // Delay loop for approximately 1ms at 12MHz\n        }\n    }\n}\n```"
  },
  {
    "role": "user",
    "content": "The C code you generated earlier failed to compile in Keil uVision5. Please revise your code according to the following compiler feedback and output as required:###\\Revised C Code###\n```code your code```\nCompiler feedback：\nC51 COMPILER V9.59.0.0 - SN: T1DZC-JTZ2TC\nCOPYRIGHT Copyright (C) 2012 - 2018 ARM Ltd and ARM Germany GmbH. All rights reserved.\n*** ERROR C141 IN LINE 45 OF C:/Users/12240/Desktop/ai-project/aiDjangoProject/media/output/TESToutput.c: syntax error near ';', expected 'hdata'\n\nC51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)\n\n"
  },
  {
    "role": "assistant",
    "content": "Looking at the compiler error, it appears there's a syntax issue around line 45. The error \"expected 'hdata'\" suggests there might be an issue with the array declarations or function prototypes. Let me revise the code to fix this compilation error.\n\n### Revised C Code ###\n\n```c\n#include <reg51.h>\n\n// Pin definitions\nsbit SDA = P1^0;\nsbit SCL = P1^1;\nsbit LED_MANUAL = P1^2;\nsbit LED_AUTO = P1^3;\nsbit KEY_MODE = P3^5;\nsbit KEY_UP = P3^0;\nsbit KEY_DOWN = P3^1;\nsbit KEY_LEFT = P3^2;\nsbit KEY_RIGHT = P3^3;\n\n// Global variables\nunsigned char system_mode;\nunsigned char motor_step_v;\nunsigned char motor_step_h;\nunsigned char sensor_data[4];\nbit error_flag;\nunsigned char timer_count;\nbit led_blink_state;\n\n// Step sequences for motors\nunsigned char v_motor_forward[8] = {0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09};\nunsigned char v_motor_backward[8] = {0x09, 0x08, 0x0C, 0x04, 0x06, 0x02, 0x03, 0x01};\nunsigned char h_motor_forward[8] = {0x10, 0x30, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x90};\nunsigned char h_motor_backward[8] = {0x90, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x30, 0x10};\n\n// Function declarations\nvoid system_init(void);\nvoid timer0_init(void);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid i2c_send_byte(unsigned char dat);\nunsigned char i2c_read_byte(void);\nvoid i2c_ack(void);\nvoid i2c_nack(void);\nunsigned char pcf8591_read(unsigned char channel);\nvoid read_sensors(void);\nvoid key_scan(void);\nvoid auto_tracking(void);\nvoid motor_control(void);\nvoid error_check(void);\nvoid led_update(void);\nvoid delay_ms(unsigned int ms);\n\nvoid main(void)\n{\n    system_init();\n    timer0_init();\n    \n    while(1)\n    {\n        read_sensors();\n        key_scan();\n        error_check();\n        \n        if(!error_flag)\n        {\n            if(system_mode == 1)\n            {\n                auto_tracking();\n            }\n            motor_control();\n        }\n        \n        led_update();\n        delay_ms(10);\n    }\n}\n\nvoid system_init(void)\n{\n    P1 = 0xFF;\n    P2 = 0x00;\n    P3 = 0xFF;\n    \n    LED_MANUAL = 1;\n    LED_AUTO = 0;\n    system_mode = 0;\n    motor_step_v = 0;\n    motor_step_h = 0;\n    error_flag = 0;\n    timer_count = 0;\n    led_blink_state = 0;\n    \n    EA = 1;\n}\n\nvoid timer0_init(void)\n{\n    TMOD = 0x01;\n    TH0 = 0xF6;\n    TL0 = 0x3C;\n    ET0 = 1;\n    TR0 = 1;\n}\n\nvoid timer0_isr(void) interrupt 1\n{\n    TH0 = 0xF6;\n    TL0 = 0x3C;\n    \n    timer_count++;\n    if(timer_count >= 100)\n    {\n        timer_count = 0;\n        led_blink_state = !led_blink_state;\n    }\n}\n\nvoid i2c_start(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SDA = 0;\n    SCL = 0;\n}\n\nvoid i2c_stop(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SDA = 1;\n}\n\nvoid i2c_send_byte(unsigned char dat)\n{\n    unsigned char i;\n    for(i = 0; i < 8; i++)\n    {\n        if(dat & 0x80)\n            SDA = 1;\n        else\n            SDA = 0;\n        dat <<= 1;\n        SCL = 1;\n        SCL = 0;\n    }\n}\n\nunsigned char i2c_read_byte(void)\n{\n    unsigned char i;\n    unsigned char dat;\n    \n    dat = 0;\n    SDA = 1;\n    for(i = 0; i < 8; i++)\n    {\n        SCL = 1;\n        dat <<= 1;\n        if(SDA)\n            dat |= 0x01;\n        SCL = 0;\n    }\n    return dat;\n}\n\nvoid i2c_ack(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SCL = 0;\n}\n\nvoid i2c_nack(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SCL = 0;\n}\n\nunsigned char pcf8591_read(unsigned char channel)\n{\n    unsigned char dat;\n    \n    i2c_start();\n    i2c_send_byte(0x90);\n    i2c_ack();\n    i2c_send_byte(channel);\n    i2c_ack();\n    \n    i2c_start();\n    i2c_send_byte(0x91);\n    i2c_ack();\n    dat = i2c_read_byte();\n    i2c_nack();\n    i2c_stop();\n    \n    return dat;\n}\n\nvoid read_sensors(void)\n{\n    sensor_data[0] = pcf8591_read(0);\n    sensor_data[1] = pcf8591_read(1);\n    sensor_data[2] = pcf8591_read(2);\n    sensor_data[3] = pcf8591_read(3);\n}\n\nvoid key_scan(void)\n{\n    static unsigned char key_state = 0xFF;\n    unsigned char key_current;\n    \n    key_current = P3 & 0x3F;\n    \n    if((key_state & 0x20) && !(key_current & 0x20))\n    {\n        system_mode = !system_mode;\n        delay_ms(20);\n    }\n    \n    if(system_mode == 0)\n    {\n        if(!(key_current & 0x01))\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            P2 = (P2 & 0x0F) | (v_motor_forward[motor_step_v] & 0x0F);\n        }\n        else if(!(key_current & 0x02))\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            P2 = (P2 & 0x0F) | (v_motor_backward[motor_step_v] & 0x0F);\n        }\n        else if(!(key_current & 0x04))\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            P2 = (P2 & 0xF0) | (h_motor_backward[motor_step_h] >> 4);\n        }\n        else if(!(key_current & 0x08))\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            P2 = (P2 & 0xF0) | (h_motor_forward[motor_step_h] >> 4);\n        }\n    }\n    \n    key_state = key_current;\n}\n\nvoid auto_tracking(void)\n{\n    int diff_v;\n    int diff_h;\n    \n    diff_v = (int)sensor_data[1] - (int)sensor_data[0];\n    \n    if(diff_v >= 15)\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        P2 = (P2 & 0x0F) | (v_motor_forward[motor_step_v] & 0x0F);\n    }\n    else if(diff_v <= -15)\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        P2 = (P2 & 0x0F) | (v_motor_backward[motor_step_v] & 0x0F);\n    }\n    \n    diff_h = (int)sensor_data[3] - (int)sensor_data[2];\n    \n    if(diff_h >= 15)\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        P2 = (P2 & 0xF0) | (h_motor_backward[motor_step_h] >> 4);\n    }\n    else if(diff_h <= -15)\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        P2 = (P2 & 0xF0) | (h_motor_forward[motor_step_h] >> 4);\n    }\n}\n\nvoid motor_control(void)\n{\n    // Motor control logic is implemented in key_scan and auto_tracking\n}\n\nvoid error_check(void)\n{\n    unsigned char i;\n    error_flag = 0;\n    \n    for(i = 0; i < 4; i++)\n    {\n        if(sensor_data[i] == 0 || sensor_data[i] == 255)\n        {\n            error_flag = 1;\n            break;\n        }\n    }\n}\n\nvoid led_update(void)\n{\n    if(error_flag)\n    {\n        LED_MANUAL = led_blink_state;\n        LED_AUTO = led_blink_state;\n    }\n    else\n    {\n        if(system_mode == 0)\n        {\n            LED_MANUAL = 1;\n            LED_AUTO = 0;\n        }\n        else\n        {\n            LED_MANUAL = 0;\n            LED_AUTO = 1;\n        }\n    }\n}\n\nvoid delay_ms(unsigned int ms)\n{\n    unsigned int i;\n    unsigned int j;\n    for(i = 0; i < ms; i++)\n    {\n        for(j = 0; j < 110; j++)\n        {\n            // Empty delay loop\n        }\n    }\n}\n```"
  },
  {
    "role": "user",
    "content": "The C code you generated earlier failed to compile in Keil uVision5. Please revise your code according to the following compiler feedback and output as required:###\\Revised C Code###\n```code your code```\nCompiler feedback：\nC51 COMPILER V9.59.0.0 - SN: T1DZC-JTZ2TC\nCOPYRIGHT Copyright (C) 2012 - 2018 ARM Ltd and ARM Germany GmbH. All rights reserved.\n*** ERROR C141 IN LINE 45 OF C:/Users/12240/Desktop/ai-project/aiDjangoProject/media/output/TESToutput.c: syntax error near ';', expected 'hdata'\n\nC51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)\n\n"
  },
  {
    "role": "assistant",
    "content": "Looking at the error message, it seems there's a syntax issue around line 45. The error \"expected 'hdata'\" suggests a problem with function declarations or variable definitions. Let me rewrite the code with proper C51 syntax.\n\n### Revised C Code ###\n\n```c\n#include <reg51.h>\n\nsbit SDA = P1^0;\nsbit SCL = P1^1;\nsbit LED_MANUAL = P1^2;\nsbit LED_AUTO = P1^3;\nsbit KEY_MODE = P3^5;\nsbit KEY_UP = P3^0;\nsbit KEY_DOWN = P3^1;\nsbit KEY_LEFT = P3^2;\nsbit KEY_RIGHT = P3^3;\n\nunsigned char system_mode;\nunsigned char motor_step_v;\nunsigned char motor_step_h;\nunsigned char sensor_data[4];\nbit error_flag;\nunsigned char timer_count;\nbit led_blink_state;\n\nunsigned char v_motor_forward[8];\nunsigned char v_motor_backward[8];\nunsigned char h_motor_forward[8];\nunsigned char h_motor_backward[8];\n\nvoid system_init(void);\nvoid timer0_init(void);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid i2c_send_byte(unsigned char dat);\nunsigned char i2c_read_byte(void);\nvoid i2c_ack(void);\nvoid i2c_nack(void);\nunsigned char pcf8591_read(unsigned char channel);\nvoid read_sensors(void);\nvoid key_scan(void);\nvoid auto_tracking(void);\nvoid motor_control(void);\nvoid error_check(void);\nvoid led_update(void);\nvoid delay_ms(unsigned int ms);\nvoid init_motor_arrays(void);\n\nvoid init_motor_arrays(void)\n{\n    v_motor_forward[0] = 0x01;\n    v_motor_forward[1] = 0x03;\n    v_motor_forward[2] = 0x02;\n    v_motor_forward[3] = 0x06;\n    v_motor_forward[4] = 0x04;\n    v_motor_forward[5] = 0x0C;\n    v_motor_forward[6] = 0x08;\n    v_motor_forward[7] = 0x09;\n    \n    v_motor_backward[0] = 0x09;\n    v_motor_backward[1] = 0x08;\n    v_motor_backward[2] = 0x0C;\n    v_motor_backward[3] = 0x04;\n    v_motor_backward[4] = 0x06;\n    v_motor_backward[5] = 0x02;\n    v_motor_backward[6] = 0x03;\n    v_motor_backward[7] = 0x01;\n    \n    h_motor_forward[0] = 0x10;\n    h_motor_forward[1] = 0x30;\n    h_motor_forward[2] = 0x20;\n    h_motor_forward[3] = 0x60;\n    h_motor_forward[4] = 0x40;\n    h_motor_forward[5] = 0xC0;\n    h_motor_forward[6] = 0x80;\n    h_motor_forward[7] = 0x90;\n    \n    h_motor_backward[0] = 0x90;\n    h_motor_backward[1] = 0x80;\n    h_motor_backward[2] = 0xC0;\n    h_motor_backward[3] = 0x40;\n    h_motor_backward[4] = 0x60;\n    h_motor_backward[5] = 0x20;\n    h_motor_backward[6] = 0x30;\n    h_motor_backward[7] = 0x10;\n}\n\nvoid main(void)\n{\n    system_init();\n    init_motor_arrays();\n    timer0_init();\n    \n    while(1)\n    {\n        read_sensors();\n        key_scan();\n        error_check();\n        \n        if(!error_flag)\n        {\n            if(system_mode == 1)\n            {\n                auto_tracking();\n            }\n            motor_control();\n        }\n        \n        led_update();\n        delay_ms(10);\n    }\n}\n\nvoid system_init(void)\n{\n    P1 = 0xFF;\n    P2 = 0x00;\n    P3 = 0xFF;\n    \n    LED_MANUAL = 1;\n    LED_AUTO = 0;\n    system_mode = 0;\n    motor_step_v = 0;\n    motor_step_h = 0;\n    error_flag = 0;\n    timer_count = 0;\n    led_blink_state = 0;\n    \n    EA = 1;\n}\n\nvoid timer0_init(void)\n{\n    TMOD = 0x01;\n    TH0 = 0xF6;\n    TL0 = 0x3C;\n    ET0 = 1;\n    TR0 = 1;\n}\n\nvoid timer0_isr(void) interrupt 1\n{\n    TH0 = 0xF6;\n    TL0 = 0x3C;\n    \n    timer_count++;\n    if(timer_count >= 100)\n    {\n        timer_count = 0;\n        led_blink_state = !led_blink_state;\n    }\n}\n\nvoid i2c_start(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SDA = 0;\n    SCL = 0;\n}\n\nvoid i2c_stop(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SDA = 1;\n}\n\nvoid i2c_send_byte(unsigned char dat)\n{\n    unsigned char i;\n    for(i = 0; i < 8; i++)\n    {\n        if(dat & 0x80)\n        {\n            SDA = 1;\n        }\n        else\n        {\n            SDA = 0;\n        }\n        dat = dat << 1;\n        SCL = 1;\n        SCL = 0;\n    }\n}\n\nunsigned char i2c_read_byte(void)\n{\n    unsigned char i;\n    unsigned char dat = 0;\n    \n    SDA = 1;\n    for(i = 0; i < 8; i++)\n    {\n        SCL = 1;\n        dat = dat << 1;\n        if(SDA)\n        {\n            dat = dat | 0x01;\n        }\n        SCL = 0;\n    }\n    return dat;\n}\n\nvoid i2c_ack(void)\n{\n    SDA = 0;\n    SCL = 1;\n    SCL = 0;\n}\n\nvoid i2c_nack(void)\n{\n    SDA = 1;\n    SCL = 1;\n    SCL = 0;\n}\n\nunsigned char pcf8591_read(unsigned char channel)\n{\n    unsigned char dat;\n    \n    i2c_start();\n    i2c_send_byte(0x90);\n    i2c_ack();\n    i2c_send_byte(channel);\n    i2c_ack();\n    \n    i2c_start();\n    i2c_send_byte(0x91);\n    i2c_ack();\n    dat = i2c_read_byte();\n    i2c_nack();\n    i2c_stop();\n    \n    return dat;\n}\n\nvoid read_sensors(void)\n{\n    sensor_data[0] = pcf8591_read(0);\n    sensor_data[1] = pcf8591_read(1);\n    sensor_data[2] = pcf8591_read(2);\n    sensor_data[3] = pcf8591_read(3);\n}\n\nvoid key_scan(void)\n{\n    static unsigned char key_state = 0xFF;\n    unsigned char key_current;\n    unsigned char temp;\n    \n    key_current = P3 & 0x3F;\n    \n    if((key_state & 0x20) && !(key_current & 0x20))\n    {\n        system_mode = !system_mode;\n        delay_ms(20);\n    }\n    \n    if(system_mode == 0)\n    {\n        if(!(key_current & 0x01))\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            temp = P2 & 0x0F;\n            P2 = temp | (v_motor_forward[motor_step_v] << 4);\n        }\n        else if(!(key_current & 0x02))\n        {\n            motor_step_v = (motor_step_v + 1) & 0x07;\n            temp = P2 & 0x0F;\n            P2 = temp | (v_motor_backward[motor_step_v] << 4);\n        }\n        else if(!(key_current & 0x04))\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            temp = P2 & 0xF0;\n            P2 = temp | (h_motor_backward[motor_step_h] & 0x0F);\n        }\n        else if(!(key_current & 0x08))\n        {\n            motor_step_h = (motor_step_h + 1) & 0x07;\n            temp = P2 & 0xF0;\n            P2 = temp | (h_motor_forward[motor_step_h] & 0x0F);\n        }\n    }\n    \n    key_state = key_current;\n}\n\nvoid auto_tracking(void)\n{\n    int diff_v;\n    int diff_h;\n    unsigned char temp;\n    \n    diff_v = (int)sensor_data[1] - (int)sensor_data[0];\n    \n    if(diff_v >= 15)\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        temp = P2 & 0x0F;\n        P2 = temp | (v_motor_forward[motor_step_v] << 4);\n    }\n    else if(diff_v <= -15)\n    {\n        motor_step_v = (motor_step_v + 1) & 0x07;\n        temp = P2 & 0x0F;\n        P2 = temp | (v_motor_backward[motor_step_v] << 4);\n    }\n    \n    diff_h = (int)sensor_data[3] - (int)sensor_data[2];\n    \n    if(diff_h >= 15)\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        temp = P2 & 0xF0;\n        P2 = temp | (h_motor_backward[motor_step_h] & 0x0F);\n    }\n    else if(diff_h <= -15)\n    {\n        motor_step_h = (motor_step_h + 1) & 0x07;\n        temp = P2 & 0xF0;\n        P2 = temp | (h_motor_forward[motor_step_h] & 0x0F);\n    }\n}\n\nvoid motor_control(void)\n{\n    // Motor control logic is implemented in key_scan and auto_tracking\n}\n\nvoid error_check(void)\n{\n    unsigned char i;\n    error_flag = 0;\n    \n    for(i = 0; i < 4; i++)\n    {\n        if(sensor_data[i] == 0 || sensor_data[i] == 255)\n        {\n            error_flag = 1;\n            break;\n        }\n    }\n}\n\nvoid led_update(void)\n{\n    if(error_flag)\n    {\n        LED_MANUAL = led_blink_state;\n        LED_AUTO = led_blink_state;\n    }\n    else\n    {\n        if(system_mode == 0)\n        {\n            LED_MANUAL = 1;\n            LED_AUTO = 0;\n        }\n        else\n        {\n            LED_MANUAL = 0;\n            LED_AUTO = 1;\n        }\n    }\n}\n\nvoid delay_ms(unsigned int ms)\n{\n    unsigned int i;\n    unsigned int j;\n    for(i = 0; i < ms; i++)\n    {\n        for(j = 0; j < 110; j++)\n        {\n            // Empty delay loop for 1ms at 12MHz\n        }\n    }\n}\n```"
  }
]