[
  {
    "role": "system",
    "content": "You will serve as an experienced embedded system design engineer. I will provide you with a requirements document and corresponding code. Please analyze the relationship between the requirements document and the reference code, then implement three versions of the code.These codes need to maintain the same functional logic as the original code, but should be written using the following three programming styles respectively:\n1.Structured programming style\n2.Modular programming style\n3.Procedural programming style.The output must be complete code, requiring C language code.\nOutput requirements 1.Output requirement 1: All code for each style should not be separated into files, but should be implemented in a single file.\n2.Output requirements in the following format:\n###Structured programming style reference###```Your first code```\n###Modular programming style reference###```Your second code```\n###Procedural programming style reference###```Your third code```。\nDo not output any other unnecessary thing"
  },
  {
    "role": "user",
    "content": "参考代码：\n---\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15               // 容差值\n#define PCF8591 0x90         // PCF8591 地址 \n\n// IO定义\nsbit SCL=P1^1;               // I2C时钟线接口 \nsbit SDA=P1^0;               // I2C数据线接口 \nsbit led_1=P1^2;             // 手动指示灯\nsbit led_2=P1^3;             // 自动指示灯\nsbit key_Up=P3^4;            // 手动控制上按键\nsbit key_Down=P3^6;          // 手动控制下按键\nsbit key_Left=P3^3;          // 手动控制左按键\nsbit key_Right=P3^7;         // 手动控制右按键\nsbit key_state=P3^5;         // 手自动切换按键\n\n// 步进电机控制序列\nuchar code FirstSet_FWD[]={0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09}; // 正转序列(垂直方向)\nuchar code FirstSet_REV[]={0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01}; // 反转序列\nuchar code Secondset_FWD[]={0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90}; // 正转序列(水平方向)\nuchar code Secondset_REV[]={0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10}; // 反转序列\n\n// 全局变量\nuint angle_X=800, angle_Y=800;  // 电机转动角度值\nbit DIR_X, DIR_Y;               // 转动方向标志位\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\n// I2C通信基本函数\nvoid PCF8591_Delay() { ; } \n  \nvoid start() { \n    SDA=1; \n    PCF8591_Delay(); \n    SCL=1; \n    PCF8591_Delay(); \n    SDA=0; \n    PCF8591_Delay(); \n} \n  \nvoid stop() { \n    SDA=0; \n    PCF8591_Delay(); \n    SCL=1; \n    PCF8591_Delay(); \n    SDA=1; \n    PCF8591_Delay(); \n} \n\nvoid respons() { \n    uchar i=0; \n    SCL=1; \n    PCF8591_Delay(); \n    while((SDA==1) && (i<250)) \n        i++; \n    SCL=0; \n    PCF8591_Delay(); \n} \n  \nvoid init() { \n    SDA=1; \n    PCF8591_Delay(); \n    SCL=1; \n    PCF8591_Delay();     \n} \n  \nuchar read_byte() { \n    uchar i, k=0; \n    SCL=0; \n    PCF8591_Delay(); \n    SDA=1; \n    PCF8591_Delay(); \n    for(i=0; i<8; i++) { \n        SCL=1; \n        PCF8591_Delay(); \n        k=(k<<1)|SDA;\n        SCL=0; \n        PCF8591_Delay(); \n    } \n    return k; \n} \n  \nvoid write_byte(uchar date) { \n    uchar i, temp; \n    temp=date; \n    for(i=0; i<8; i++) { \n        temp=temp<<1;\n        SCL=0;\n        PCF8591_Delay(); \n        SDA=CY; \n        PCF8591_Delay(); \n        SCL=1; \n        PCF8591_Delay();             \n    }    \n    SCL=0; \n    PCF8591_Delay(); \n    SDA=1; \n    PCF8591_Delay(); \n} \n\n// PCF8591操作函数\nvoid write_add(uchar control, uchar date) { \n    start(); \n    write_byte(PCF8591);\n    respons(); \n    write_byte(control); \n    respons(); \n    write_byte(date); \n    respons(); \n    stop(); \n} \n  \nuchar read_add(uchar control) { \n    uchar date; \n    start(); \n    write_byte(PCF8591); \n    respons(); \n    write_byte(control); \n    respons(); \n    start(); \n    write_byte(PCF8591+1);\n    respons(); \n    date=read_byte(); \n    stop(); \n    return date; \n} \n\nuchar DAC(uchar light) {\n    start();\n    write_byte(PCF8591); \n    respons();\n    write_byte(0x40);\n    respons();\n    write_byte(light);\n    respons();\n    stop();\n    return(1);\n}\n\n// 系统功能函数\nvoid delay(uint T) {\n    while(T--);\n}\n\nvoid key() {\n    // 模式切换检测\n    if(!key_state) {\n        delay(1000);\n        if(!key_state) {\n            while(!key_state) \n                Down_CB=Up_CB=Right_CB=Left_CB=0;\n            SYS_mode=!SYS_mode;\n            angle_X=angle_Y=800;\n            DIR_X=DIR_Y=0;\n        }\n    }\n    \n    // 手动模式按键处理\n    if(!SYS_mode) {\n        // 垂直方向控制\n        if(!key_Up) {\n            Up_CB=1;\n            Down_CB=0;  \n        } else if(!key_Down) {\n            Up_CB=0;\n            Down_CB=1;\n        } else {\n            Down_CB=0;\n            Up_CB=0;\n        }\n        \n        // 水平方向控制\n        if(!key_Left) {\n            Left_CB=1;\n            Right_CB=0;\n        } else if(!key_Right) {\n            Left_CB=0;\n            Right_CB=1;\n        } else {\n            Right_CB=0;\n            Left_CB=0;\n        }       \n    }\n}\n\nvoid proc() {\n    // 自动模式且无故障时执行\n    if(SYS_mode && SYS_ERROR==0) {\n        // 垂直方向控制逻辑\n        if(AD_Up > AD_Down) {\n            Up_CB=0;\n            if(AD_Up-AD_Down >= Tol) {\n                Down_CB=1;\n            } else if(AD_Up-AD_Down <= 4) {\n                Down_CB=0;\n            }\n        } else {\n            Down_CB=0;\n            if(AD_Down-AD_Up >= Tol) {\n                Up_CB=1;\n            } else if(AD_Down-AD_Up <= 4) {\n                Up_CB=0;\n            }\n        }\n        \n        // 水平方向控制逻辑\n        if(AD_Left > AD_Right) {\n            Right_CB=0;\n            if(AD_Left-AD_Right >= Tol) {\n                Left_CB=1;\n            } else if(AD_Left-AD_Right <= 7) {\n                Left_CB=0;\n            }\n        } else {\n            Left_CB=0;\n            if(AD_Right-AD_Left >= Tol) {\n                Right_CB=1;\n            } else if(AD_Right-AD_Left <= 7) {\n                Right_CB=0;\n            }\n        }   \n    } else if(SYS_mode && SYS_ERROR) {\n        // 故障状态下停止所有电机\n        Right_CB=Left_CB=Up_CB=Down_CB=0;\n    }\n}\n\nvoid main(void) {\n    // 初始化\n    TMOD=0x01;\n    TH0=0xf6;\n    TL0=0x3b;\n    EA=1;\n    ET0=1;\n    TR0=1;\n    init();\n    \n    // 主循环\n    while(1) {\n        // 按键检测\n        key();\n        \n        // 读取传感器数据\n        AD_Down=read_add(0x00);\n        AD_Up=read_add(0x01);\n        AD_Right=read_add(0x02);\n        AD_Left=read_add(0x03);\n        \n        // 传感器故障检测\n        if(AD_Down==255 || AD_Down==0 || AD_Up==255 || AD_Up==0 || \n           AD_Right==255 || AD_Right==0 || AD_Left==255 || AD_Left==0) {\n            SYS_ERROR=1;\n        } else {\n            SYS_ERROR=0;\n        }\n        \n        // 运行自动控制程序\n        proc();\n        \n        // 更新LED状态\n        if(SYS_ERROR==0) {\n            if(!SYS_mode) {\n                led_1=0;\n                led_2=1;\n            } else {\n                led_1=1;\n                led_2=0;\n            }\n        }\n    }\n}\n\n// 定时器中断服务程序\nvoid init_1() interrupt 1 {\n    TH0=0xf6;\n    TL0=0x3b;\n    \n    // 垂直方向电机控制\n    if(Up_CB) {\n        P2=P2&0xf0|FirstSet_FWD[loop];\n    } else if(Down_CB) {\n        P2=P2&0xf0|FirstSet_REV[loop];\n    } else {\n        P2=P2&0xf0;\n    }\n\n    // 水平方向电机控制\n    if(Left_CB) {\n        P2=P2&0x0f|Secondset_FWD[loop];\n    } else if(Right_CB) {\n        P2=P2&0x0f|Secondset_REV[loop];\n    } else {\n        P2=P2&0x0f;\n    } \n    \n    // 更新步进序列索引\n    loop=(loop+1)%8;\n\n    // 故障指示灯闪烁控制\n    if(SYS_ERROR==1) {\n        blink_ms++;\n        if(blink_ms>39) {\n            blink_ms=0;\n            led_1=!led_1;\n            led_2=led_1;\n        }   \n    }\n}\n\n---"
  },
  {
    "role": "assistant",
    "content": "###Structured programming style reference###\n```c\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\nvoid PCF8591_Delay() {;}\n\nvoid start() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid stop() {\n    SDA = 0; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid respons() {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid init() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n}\n\nuchar read_byte() {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid write_byte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay();\n        SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid write_add(uchar control, uchar date) {\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    write_byte(date);\n    respons();\n    stop();\n}\n\nuchar read_add(uchar control) {\n    uchar date;\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(control);\n    respons();\n    start();\n    write_byte(PCF8591 + 1);\n    respons();\n    date = read_byte();\n    stop();\n    return date;\n}\n\nuchar DAC(uchar light) {\n    start();\n    write_byte(PCF8591);\n    respons();\n    write_byte(0x40);\n    respons();\n    write_byte(light);\n    respons();\n    stop();\n    return 1;\n}\n\nvoid delay(uint T) {\n    while (T--);\n}\n\nvoid key() {\n    if (!key_state) {\n        delay(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid proc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    init();\n\n    while (1) {\n        key();\n        AD_Down = read_add(0x00);\n        AD_Up = read_add(0x01);\n        AD_Right = read_add(0x02);\n        AD_Left = read_add(0x03);\n\n        if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 || AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n            SYS_ERROR = 1;\n        } else {\n            SYS_ERROR = 0;\n        }\n\n        proc();\n        if (SYS_ERROR == 0) {\n            if (!SYS_mode) {\n                led_1 = 0; led_2 = 1;\n            } else {\n                led_1 = 1; led_2 = 0;\n            }\n        }\n    }\n}\n\nvoid init_1() interrupt 1 {\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n```\n\n###Modular programming style reference###\n```c\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\n//------------ I2C模块 ------------\nvoid PCF8591_Delay() {;}\n\nvoid I2C_Start() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 0; PCF8591_Delay();\n}\n\nvoid I2C_Stop() {\n    SDA = 0; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\nvoid I2C_Response() {\n    uchar i = 0;\n    SCL = 1; PCF8591_Delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; PCF8591_Delay();\n}\n\nvoid I2C_Init() {\n    SDA = 1; PCF8591_Delay();\n    SCL = 1; PCF8591_Delay();\n}\n\nuchar I2C_ReadByte() {\n    uchar i, k = 0;\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; PCF8591_Delay();\n        k = (k << 1) | SDA;\n        SCL = 0; PCF8591_Delay();\n    }\n    return k;\n}\n\nvoid I2C_WriteByte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; PCF8591_Delay();\n        SDA = CY;\n        PCF8591_Delay();\n        SCL = 1; PCF8591_Delay();\n    }\n    SCL = 0; PCF8591_Delay();\n    SDA = 1; PCF8591_Delay();\n}\n\n//------------ PCF8591模块 ------------\nvoid PCF8591_Write(uchar control, uchar data) {\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(control);\n    I2C_Response();\n    I2C_WriteByte(data);\n    I2C_Response();\n    I2C_Stop();\n}\n\nuchar PCF8591_Read(uchar control) {\n    uchar result;\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(control);\n    I2C_Response();\n    I2C_Start();\n    I2C_WriteByte(PCF8591 + 1);\n    I2C_Response();\n    result = I2C_ReadByte();\n    I2C_Stop();\n    return result;\n}\n\nuchar PCF8591_DAC(uchar light) {\n    I2C_Start();\n    I2C_WriteByte(PCF8591);\n    I2C_Response();\n    I2C_WriteByte(0x40);\n    I2C_Response();\n    I2C_WriteByte(light);\n    I2C_Response();\n    I2C_Stop();\n    return 1;\n}\n\n//------------ 控制与延时模块 ------------\nvoid DelayMs(uint T) {\n    while (T--);\n}\n\nvoid ManualKeyCheck() {\n    if (!key_state) {\n        DelayMs(1000);\n        if (!key_state) {\n            while (!key_state) Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid AutoCtrlProc() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid SystemErrorCheck() {\n    if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n        AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0) {\n        SYS_ERROR = 1;\n    } else {\n        SYS_ERROR = 0;\n    }\n}\n\nvoid LEDUpdate() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) {\n            led_1 = 0; led_2 = 1;\n        } else {\n            led_1 = 1; led_2 = 0;\n        }\n    }\n}\n\n//------------ 主函数与中断服务 ------------\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    I2C_Init();\n\n    while (1) {\n        ManualKeyCheck();\n        AD_Down = PCF8591_Read(0x00);\n        AD_Up = PCF8591_Read(0x01);\n        AD_Right = PCF8591_Read(0x02);\n        AD_Left = PCF8591_Read(0x03);\n\n        SystemErrorCheck();\n        AutoCtrlProc();\n        LEDUpdate();\n    }\n}\n\nvoid Timer0_ISR() interrupt 1 {\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n```\n\n###Procedural programming style reference###\n```c\n#include <reg52.h>\n#define uchar unsigned char\n#define uint unsigned int\n#define Tol 15\n#define PCF8591 0x90\n\nsbit SCL = P1^1;\nsbit SDA = P1^0;\nsbit led_1 = P1^2;\nsbit led_2 = P1^3;\nsbit key_Up = P3^4;\nsbit key_Down = P3^6;\nsbit key_Left = P3^3;\nsbit key_Right = P3^7;\nsbit key_state = P3^5;\n\nuchar code FirstSet_FWD[] = {0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};\nuchar code FirstSet_REV[] = {0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};\nuchar code Secondset_FWD[] = {0x10,0x30,0x20,0x60,0x40,0xc0,0x80,0x90};\nuchar code Secondset_REV[] = {0x90,0x80,0xc0,0x40,0x60,0x20,0x30,0x10};\n\nuint angle_X = 800, angle_Y = 800;\nbit DIR_X, DIR_Y;\nuchar loop, AD_Up, AD_Down, AD_Left, AD_Right, ms, blink_ms;\nbit Up_CB, Down_CB, Left_CB, Right_CB, SYS_mode, SYS_ERROR;\n\nvoid pcf_delay() {\n    ;\n}\n\nvoid i2c_start() {\n    SDA = 1; pcf_delay();\n    SCL = 1; pcf_delay();\n    SDA = 0; pcf_delay();\n}\n\nvoid i2c_stop() {\n    SDA = 0; pcf_delay();\n    SCL = 1; pcf_delay();\n    SDA = 1; pcf_delay();\n}\n\nvoid i2c_resp() {\n    uchar i = 0;\n    SCL = 1; pcf_delay();\n    while ((SDA == 1) && (i < 250)) i++;\n    SCL = 0; pcf_delay();\n}\n\nvoid i2c_init() {\n    SDA = 1; pcf_delay();\n    SCL = 1; pcf_delay();\n}\n\nuchar i2c_readbyte() {\n    uchar i, k = 0;\n    SCL = 0; pcf_delay();\n    SDA = 1; pcf_delay();\n    for (i = 0; i < 8; i++) {\n        SCL = 1; pcf_delay();\n        k = (k << 1) | SDA;\n        SCL = 0; pcf_delay();\n    }\n    return k;\n}\n\nvoid i2c_writebyte(uchar date) {\n    uchar i, temp;\n    temp = date;\n    for (i = 0; i < 8; i++) {\n        temp = temp << 1;\n        SCL = 0; pcf_delay();\n        SDA = CY; pcf_delay();\n        SCL = 1; pcf_delay();\n    }\n    SCL = 0; pcf_delay();\n    SDA = 1; pcf_delay();\n}\n\nuchar read_sensor(uchar channel) {\n    uchar d;\n    i2c_start();\n    i2c_writebyte(PCF8591); i2c_resp();\n    i2c_writebyte(channel); i2c_resp();\n    i2c_start();\n    i2c_writebyte(PCF8591 + 1); i2c_resp();\n    d = i2c_readbyte();\n    i2c_stop();\n    return d;\n}\n\nuchar write_dac(uchar light) {\n    i2c_start();\n    i2c_writebyte(PCF8591); i2c_resp();\n    i2c_writebyte(0x40); i2c_resp();\n    i2c_writebyte(light); i2c_resp();\n    i2c_stop();\n    return 1;\n}\n\nvoid wait(uint t) {\n    while (t--);\n}\n\nvoid check_key() {\n    if (!key_state) {\n        wait(1000);\n        if (!key_state) {\n            while (!key_state)\n                Down_CB = Up_CB = Right_CB = Left_CB = 0;\n            SYS_mode = !SYS_mode;\n            angle_X = angle_Y = 800;\n            DIR_X = DIR_Y = 0;\n        }\n    }\n\n    if (!SYS_mode) {\n        if (!key_Up) {\n            Up_CB = 1; Down_CB = 0;\n        } else if (!key_Down) {\n            Up_CB = 0; Down_CB = 1;\n        } else {\n            Down_CB = 0; Up_CB = 0;\n        }\n        if (!key_Left) {\n            Left_CB = 1; Right_CB = 0;\n        } else if (!key_Right) {\n            Left_CB = 0; Right_CB = 1;\n        } else {\n            Right_CB = 0; Left_CB = 0;\n        }\n    }\n}\n\nvoid auto_control() {\n    if (SYS_mode && SYS_ERROR == 0) {\n        if (AD_Up > AD_Down) {\n            Up_CB = 0;\n            if (AD_Up - AD_Down >= Tol) Down_CB = 1;\n            else if (AD_Up - AD_Down <= 4) Down_CB = 0;\n        } else {\n            Down_CB = 0;\n            if (AD_Down - AD_Up >= Tol) Up_CB = 1;\n            else if (AD_Down - AD_Up <= 4) Up_CB = 0;\n        }\n        if (AD_Left > AD_Right) {\n            Right_CB = 0;\n            if (AD_Left - AD_Right >= Tol) Left_CB = 1;\n            else if (AD_Left - AD_Right <= 7) Left_CB = 0;\n        } else {\n            Left_CB = 0;\n            if (AD_Right - AD_Left >= Tol) Right_CB = 1;\n            else if (AD_Right - AD_Left <= 7) Right_CB = 0;\n        }\n    } else if (SYS_mode && SYS_ERROR) {\n        Right_CB = Left_CB = Up_CB = Down_CB = 0;\n    }\n}\n\nvoid check_sys_err() {\n    if (AD_Down == 255 || AD_Down == 0 || AD_Up == 255 || AD_Up == 0 ||\n        AD_Right == 255 || AD_Right == 0 || AD_Left == 255 || AD_Left == 0)\n        SYS_ERROR = 1;\n    else\n        SYS_ERROR = 0;\n}\n\nvoid update_led() {\n    if (SYS_ERROR == 0) {\n        if (!SYS_mode) {\n            led_1 = 0; led_2 = 1;\n        } else {\n            led_1 = 1; led_2 = 0;\n        }\n    }\n}\n\nvoid main(void) {\n    TMOD = 0x01;\n    TH0 = 0xf6;\n    TL0 = 0x3b;\n    EA = 1;\n    ET0 = 1;\n    TR0 = 1;\n    i2c_init();\n\n    while (1) {\n        check_key();\n        AD_Down = read_sensor(0x00);\n        AD_Up = read_sensor(0x01);\n        AD_Right = read_sensor(0x02);\n        AD_Left = read_sensor(0x03);\n        check_sys_err();\n        auto_control();\n        update_led();\n    }\n}\n\nvoid timer0_proc() interrupt 1 {\n    TH0 = 0xf6; TL0 = 0x3b;\n    if (Up_CB) {\n        P2 = P2 & 0xf0 | FirstSet_FWD[loop];\n    } else if (Down_CB) {\n        P2 = P2 & 0xf0 | FirstSet_REV[loop];\n    } else {\n        P2 = P2 & 0xf0;\n    }\n\n    if (Left_CB) {\n        P2 = P2 & 0x0f | Secondset_FWD[loop];\n    } else if (Right_CB) {\n        P2 = P2 & 0x0f | Secondset_REV[loop];\n    } else {\n        P2 = P2 & 0x0f;\n    }\n\n    loop = (loop + 1) % 8;\n\n    if (SYS_ERROR == 1) {\n        blink_ms++;\n        if (blink_ms > 39) {\n            blink_ms = 0;\n            led_1 = !led_1;\n            led_2 = led_1;\n        }\n    }\n}\n```"
  },
  {
    "role": "user",
    "content": "procedural Compilation successful！"
  }
]